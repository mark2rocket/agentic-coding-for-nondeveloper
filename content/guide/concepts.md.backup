---
title: "기초 개발 용어"
description: "비개발자를 위한 에이전틱 코딩 가이드"
order: 1
---

# 비개발자를 위한 에이전틱 코딩(Vibe Coding) 가이드

## 📑 목차 (Table of Contents)

### 📖 기초편
- [1. 기초 개발 용어](#1-기초-개발-용어-categorized-flow)
  - [1-1. 서비스의 기본 구조](#1-1-서비스의-기본-구조-structure)
  - [1-2. 화면을 만드는 재료](#1-2-화면을-만드는-재료-interface)
  - [1-3. 개발을 돕는 도구들](#1-3-개발을-돕는-도구들-tools--tech)
  - [1-4. 데이터와 소통](#1-4-데이터와-소통-data--communication)
  - [1-5. 작업 관리와 수정](#1-5-작업-관리와-수정-workflow)
  - [1-6. 세상에 내보내기](#1-6-세상에-내보내기-deploy)

### 🚀 실전편
- [2. 에이전틱 코딩 프로세스](#2-에이전틱-코딩vibe-coding-프로세스)
  - [2-1. 기획 및 요구사항 정의](#1-기획-및-요구사항-정의-ideation)
  - [2-2. 생성 및 구현](#2-생성-및-구현-generation)
  - [2-3. 검증 및 수정](#3-검증-및-수정-iteration)

- [3. 에이전틱 코딩 툴](#3-에이전틱-코딩-툴)
  - [3-1. 안티그래비티 🌐](#3-1-안티그래비티-antigravity)
  - [3-2. 클로드코드 💻](#3-2-클로드코드-claude-code)
  - [3-3. 오 마이 클로드코드 ⚡](#3-3-오-마이-클로드코드-oh-my-claude-code)
  - [3-4. 플러그인](#3-4-클로드코드-플러그인-plugins)
  - [3-5. 활용 레퍼런스](#3-5-클로드코드-활용-레퍼런스)

### 🎓 고급편
- [4. 에이전트 오케스트레이션](#4-에이전트-오케스트레이션)
  - [4-1. 개념](#1-개념-concept)
  - [4-2. 프로세스](#2-프로세스-process)
  - [4-3. 도구와 구현](#3-도구와-구현-implementation)
  - [4-4. 복합 시스템 구축](#4-복합-시스템-구축-integrated-system)

### 💡 실습편
- [5. 실전 튜토리얼](#5-실전-튜토리얼-step-by-step)
- [6. 문제 해결 가이드](#6-문제-해결-가이드-troubleshooting)
- [7. 자주 묻는 질문](#7-자주-묻는-질문-faq)

### 📚 부록
- [8. 추천 학습 경로](#8-추천-학습-경로)
- [9. 용어 사전](#9-용어-사전)

---

## 🛠️ 도구 선택 가이드

### 나에게 맞는 도구는?

| 구분 | 안티그래비티<br/>(웹 기반 IDE) | 클로드코드<br/>(CLI) | 오마이클로드<br/>(확장팩) |
|-----|------------|-----------|------------|
| **난이도** | ⭐ 쉬움 | ⭐⭐ 보통 | ⭐⭐⭐ 어려움 |
| **설치** | 불필요 (웹) | npm 설치 | git clone |
| **UI** | 시각적 (GUI) | 터미널 (CLI) | 터미널 (CLI) |
| **속도** | 보통 | 빠름 | 매우 빠름 |
| **AI 모델** | Gemini | Claude | Claude |
| **최적 용도** | 웹 프로토타입 | 복잡한 로직 | 대규모 프로젝트 |
| **추천 대상** | 완전 초보자 | 중급 이상 | 개발 경험자 |
| **실시간 프리뷰** | ✅ 있음 | ❌ 없음 | ❌ 없음 |
| **컨텍스트 관리** | 자동 | 수동 (/compact) | 자동 최적화 |

### 🎯 선택 플로우차트

```
Q: 처음 코딩해보시나요?
  ├─ Yes → 웹 기반 IDE 추천 (StackBlitz, Replit)
  │         - 설치 불필요
  │         - 시각적 피드백
  │         - 즉시 시작 가능
  │
  └─ No → Q: 터미널이 편하신가요?
           ├─ Yes → 클로드코드
           │         └─ Q: 고급 기능 필요?
           │              ├─ Yes → 오마이클로드
           │              └─ No → 클로드코드만 사용
           │
           └─ No → 웹 기반 IDE 추천
```

### 💰 비용 비교

| 도구 | 무료 티어 | 유료 가격 |
|------|---------|---------|
| **웹 기반 IDE** | 제한적 무료 | $10-20/월 |
| **클로드코드** | API 종량제 | $3-15/1M 토큰 |
| **오마이클로드** | 무료 (오픈소스) | API 비용만 |

**예상 비용 (클로드코드 기준)**:
- 간단한 앱: $0.5~$2
- 중간 규모: $5~$20
- 대규모 프로젝트: $50+

<ToolComparisonDiagram />

---

## 1. 기초 개발 용어 (Categorized Flow)

비개발자가 개발 흐름을 이해하기 쉽도록 [구조] -> [화면] -> [도구] -> [소통] -> [저장] -> [출시] 순서로 재배치했습니다.

### 1-1. 서비스의 기본 구조 (Structure)

누가 요청하고 누가 응답하는가?

#### 서버 (Server) vs 클라이언트 (Client)

**Level.1:** 식당에 비유할 수 있습니다. 클라이언트는 음식을 주문하는 '손님', 서버는 요리를 만들어서 내주는 '주방'입니다.

**Level.2:** 클라이언트는 사용자가 보는 웹브라우저(크롬, 앱)이고, 서버는 클라이언트의 요청을 받아 데이터나 파일을 보내주는 24시간 켜진 컴퓨터입니다.

**Level.3:** 클라이언트는 UI/UX를 담당하여 사용자 입력을 받고, 서버는 비즈니스 로직(계산, 저장)을 처리하여 응답(Response)을 반환하는 컴퓨팅 리소스입니다.

```
[클라이언트] --요청(Request)--> [서버]
    ↑                              ↓
    └---------응답(Response)--------┘
```

**한줄 요약:** 화면이 이상하면 '클라이언트' 문제, 로그인이 안 되면 '서버' 문제일 확률이 높습니다.

<ClientServerDiagram />

#### 프론트엔드 (Frontend) vs 백엔드 (Backend)

**Level.1:** 프론트엔드는 예쁘게 꾸며진 식당의 '홀(식탁)', 백엔드는 손님 눈에 안 보이는 '주방과 창고'입니다.

**Level.2:** 프론트엔드는 웹사이트에서 눈에 보이는 화면(글자, 색상, 버튼), 백엔드는 회원가입 처리, 데이터 저장 등 눈에 안 보이는 뒷단 기능입니다.

**Level.3:** 프론트엔드는 HTML/CSS/JS로 브라우저에서 실행되고, 백엔드는 Java/Python/Node.js로 서버에서 데이터베이스(DB)를 다룹니다.

```javascript
// 프론트엔드 (브라우저에서 실행)
<button onClick={() => alert('클릭!')}>버튼</button>

// 백엔드 (서버에서 실행)
app.post('/login', (req, res) => { /* 로그인 처리 */ })
```

**한줄 요약:** AI에게 "디자인 수정해줘"는 프론트엔드, "기능 고쳐줘"는 백엔드 작업입니다.

<FrontendBackendDiagram />

### 1-2. 화면을 만드는 재료 (Interface)

화면은 무엇으로 만들어지는가?

#### HTML & CSS & Javascript

**Level.1:** HTML은 사람의 '뼈대', CSS는 입고 있는 '옷', Javascript는 걷고 뛰는 '근육(동작)'입니다.

**Level.2:** HTML은 웹페이지의 구조(제목, 본문), CSS는 디자인(색상, 간격), JS는 클릭했을 때 팝업이 뜨는 등의 동적인 기능을 담당합니다.

**Level.3:** 웹 표준 기술 3대장입니다. HTML로 마크업하고, CSS로 스타일링하며, JS로 DOM을 조작하여 상호작용합니다.

```html
<!-- HTML: 구조 -->
<button id="myBtn">클릭하세요</button>

<!-- CSS: 디자인 -->
<style>
  #myBtn { background: blue; color: white; }
</style>

<!-- Javascript: 동작 -->
<script>
  document.getElementById('myBtn').onclick = () => alert('안녕!');
</script>
```

**한줄 요약:** "HTML로 구조 잡고, CSS로 꾸미고, JS로 움직이게 해줘"라고 지시하세요.

#### UI (User Interface) vs UX (User Experience)

**Level.1:** UI는 숟가락의 '디자인', UX는 그 숟가락으로 밥을 먹을 때 느껴지는 '편안함'입니다.

**Level.2:** UI는 화면의 레이아웃, 폰트, 색감 등 시각적인 요소이고, UX는 사용자가 서비스를 이용하며 느끼는 경험과 만족도입니다.

**Level.3:** UI는 GUI 디자인 툴(Figma)로 작업하며, UX는 사용자 리서치와 여정 지도(User Journey)를 통해 설계합니다.

**한줄 요약:** "UI는 예쁘게 하되, UX(사용성)를 해치지 않게 버튼 위치를 잡아줘"라고 명령하세요.

### 1-3. 개발을 돕는 도구들 (Tools & Tech)

맨땅에 헤딩하지 않기 위한 도구

#### 라이브러리 (Library)

**Level.1:** 레고 블록 상자입니다. 내가 필요한 블록(바퀴, 창문)만 골라서 내 마음대로 조립합니다.

**Level.2:** 개발에 자주 쓰이는 기능(예: 차트 그리기, 날짜 계산)을 미리 만들어 모아둔 코드 묶음입니다. 필요할 때 가져다 씁니다.

**Level.3:** 개발자가 코드의 제어권을 가집니다. 대표적으로 React(UI 라이브러리), jQuery 등이 있습니다.

```javascript
// 날짜 라이브러리 사용 예시
import dayjs from 'dayjs';
const tomorrow = dayjs().add(1, 'day').format('YYYY-MM-DD');
```

**한줄 요약:** AI에게 "차트 그리는 라이브러리 써서 그래프 만들어줘"라고 하세요.

#### 프레임워크 (Framework)

**Level.1:** 모델 하우스입니다. 이미 방 구조와 배관이 다 짜여 있고, 나는 가구만 배치하면 됩니다.

**Level.2:** 뼈대와 규칙이 정해져 있는 개발 환경입니다. 내가 코드를 짤 때 이 틀의 규칙을 따라야만 작동합니다.

**Level.3:** 제어의 역전(IoC)이 일어납니다. 프레임워크가 내 코드를 호출합니다. 대표적으로 Next.js, Django가 있습니다.

```javascript
// Next.js 프레임워크 규칙에 따른 페이지 생성
export default function Home() {
  return <h1>홈페이지</h1>;  // 프레임워크가 이 함수를 호출
}
```

**한줄 요약:** "Next.js 프레임워크 기반으로 프로젝트 세팅해줘"라고 시작하세요.

#### Node.js & Next.js & Typescript

**Level.1:** Node.js는 자바스크립트를 컴퓨터에서도 돌아가게 하는 엔진, Next.js는 웹사이트 제작 키트, Typescript는 깐깐한 자바스크립트입니다.

**Level.2:** Node.js는 브라우저 밖에서 JS를 실행하는 환경(런타임), Next.js는 리액트 기반의 강력한 프레임워크, Typescript는 에러 방지를 위해 변수 타입을 미리 정하는 언어입니다.

**Level.3:** 최신 웹 개발의 표준 스택입니다. Node.js 위에서 Next.js 프레임워크를 쓰고, 언어는 안정성을 위해 Typescript를 사용합니다.

```typescript
// Typescript: 타입을 미리 지정
interface User {
  name: string;
  age: number;
}

// Next.js 페이지
export default function Page() {
  const user: User = { name: "김철수", age: 25 };
  return <div>{user.name}</div>;
}
```

**한줄 요약:** AI에게 "Node.js 환경에서 Typescript와 Next.js를 써서 개발해줘"가 가장 무난한 주문입니다.

#### MCP (Model Context Protocol)

**Level.1:** AI 비서가 여러 가지 도구를 사용할 수 있게 해주는 '만능 어댑터'입니다. 하나의 충전기로 여러 기기를 연결하듯, MCP로 AI가 다양한 프로그램을 사용할 수 있습니다.

**Level.2:** "MCP는 AI 모델이 외부 도구와 데이터 소스에 접근 가능하게 하는 표준 프로토콜"입니다. Claude가 깃허브나 노션 같은 서비스에 직접 접근할 수 있게 만들어줍니다. **탭 전환 없이 하나의 세션에서 모든 작업 완료**가 핵심입니다.

**Level.3:** Anthropic이 만든 개방형 프로토콜로, LLM이 표준화된 방식으로 외부 도구 및 데이터 소스와 통합할 수 있게 합니다. 서버-클라이언트 아키텍처로 구성되며, JSON-RPC 2.0 기반으로 통신합니다.

**CLI 설정 방법:**
```bash
# HTTP 전송 (원격 서버)
claude mcp add --transport http <name> <url>

# 예: Notion 연동
claude mcp add --transport http notion https://mcp.notion.com/mcp

# 인증 포함
claude mcp add --transport http github https://api.github.com/mcp \
  --header "Authorization: Bearer your-token"
```

**웹 앱 설정 (더 쉬운 방법):**
```
Settings → Connectors → 서버 찾기 → Configure → 권한 부여
```

**실전 활용 사례:**

| 활용 분야 | 예시 명령 |
|----------|---------|
| **이슈 추적** | "JIRA ENG-4521 기능 구현" |
| **데이터 쿼리** | "지난 주 가입자 찾기 (PostgreSQL)" |
| **디자인 통합** | "Figma 디자인 기반 이메일 템플릿" |
| **채널 분석** | "#engineering 채널 API 결정사항" |
| **PR 관리** | "이 PR 코드 검토" |

**권장 MCP 서버:**
- **GitHub**: 리포 관리, 이슈, PR, 코드 검색
- **Slack**: 채널 기록, 스레드 요약, 메시지 검색
- **Google Drive**: 구현 중 참조 문서
- **PostgreSQL/DB**: 직접 쿼리
- **Linear/Jira**: 이슈 통합

**⚠️ 보안 주의사항:**
타사 MCP 서버는 Anthropic 검증 없음 → 민감한 통합은 소스 코드 검토 필수

**한줄 요약:** MCP로 GitHub/Slack/Notion 연결하면 탭 전환 없이 모든 작업을 Claude 안에서 완료할 수 있습니다.

### 1-4. 데이터와 소통 (Data & Communication)

정보를 주고받고 저장하는 법

#### HTTP & 요청(Request) vs 응답(Response)

**Level.1:** HTTP는 대화 규칙(한국어, 영어), 요청은 "질문", 응답은 "대답"입니다.

**Level.2:** 인터넷상에서 정보를 주고받는 약속(프로토콜)입니다. 클라이언트가 요청을 보내면 서버가 상태 코드(200 OK, 404 Error)와 함께 응답합니다.

**Level.3:** HTTP는 Stateless 프로토콜이며, Request Header/Body에 정보를 담아 보내면 Response로 결과를 받습니다.

```javascript
// HTTP 요청 보내기
fetch('https://api.example.com/data')
  .then(res => res.json())  // 응답 받기 (200 OK)
  .catch(err => console.error(err));  // 에러 처리 (404 등)
```

**한줄 요약:** "HTTP 요청이 실패했어. 응답 코드가 몇 번인지 확인해줘"라고 물어보세요.

#### API & JSON

**Level.1:** API는 점원(주문 전달자), JSON은 주문서 양식(메뉴: 피자, 수량: 1)입니다.

**Level.2:** API는 프로그램끼리 소통하는 연결 통로, JSON은 그 통로를 지날 때 데이터를 주고받는 가장 흔한 텍스트 형식입니다.

**Level.3:** API는 Interface 규약(REST API 등)이며, JSON은 Key-Value 쌍으로 이루어진 경량 데이터 포맷입니다.

```javascript
// API 호출 → JSON 응답
const response = await fetch('/api/user/123');
const data = await response.json();
// 결과: { "name": "김철수", "age": 25, "email": "kim@example.com" }
```

**한줄 요약:** "날씨 API를 연동해서 JSON 데이터를 받아와 줘"라고 하세요.

#### DB (DataBase) & CRUD

**Level.1:** DB는 도서관의 책장, CRUD는 책을 꽂고(C), 읽고(R), 수정하고(U), 버리는(D) 4가지 동작입니다.

**Level.2:** DB는 데이터를 정리해 둔 창고(MySQL 등), CRUD는 생성(Create), 조회(Read), 수정(Update), 삭제(Delete)라는 데이터 처리의 핵심 기능입니다.

**Level.3:** 영속성 데이터를 관리하는 시스템입니다. 웹 서비스의 기능은 결국 대부분 CRUD로 귀결됩니다.

```sql
CREATE: INSERT INTO posts (title, content) VALUES ('제목', '내용');
READ:   SELECT * FROM posts WHERE id = 1;
UPDATE: UPDATE posts SET title = '수정된 제목' WHERE id = 1;
DELETE: DELETE FROM posts WHERE id = 1;
```

**한줄 요약:** "게시판의 CRUD 기능을 구현해줘"라고 하면 글쓰기/읽기/수정/삭제를 다 만들어줍니다.

### 1-5. 작업 관리와 수정 (Workflow)

코드를 저장하고 고치는 법

#### 버그 (Bug) vs 디버깅 (Debugging)

**Level.1:** 버그는 프로그램 고장, 디버깅은 고장 난 곳을 찾아 고치는 수리 과정입니다.

**Level.2:** 버그는 코드 오류로 인한 오작동, 디버깅은 로그 등을 확인해 오류 원인을 찾고 해결하는 행위입니다.

**Level.3:** 논리적 오류나 예외 상황(Exception)을 추적하여 코드를 수정하는 프로세스입니다.

```javascript
// 버그 (오타로 인한 에러)
const total = price * quanity;  // ❌ quanity는 정의되지 않음

// 디버깅 후 수정
const total = price * quantity;  // ✅ 올바른 변수명
```

**한줄 요약:** "버그가 발생했어. 에러 로그를 줄 테니 디버깅해줘"라고 시키세요.

#### 깃 (Git) & 깃허브 (Github)

**Level.1:** 깃은 게임의 '세이브 포인트' 기능, 깃허브는 세이브 파일을 모아두는 '클라우드 공유 폴더'입니다.

**Level.2:** 깃은 내 컴퓨터에서 코드 변경 내역을 관리하는 프로그램, 깃허브는 깃으로 저장한 내역을 온라인에 업로드하여 협업하는 사이트입니다.

**Level.3:** Git은 분산 버전 관리 시스템(VCS)이고, Github는 Git 리포지토리 호스팅 서비스입니다.

**한줄 요약:** "코드 수정할 때마다 깃으로 커밋하고, 깃허브에 백업해줘"라고 하세요.

#### 커밋 (Commit), 푸시 (Push), 풀 (Pull)

**Level.1:** 커밋은 '저장 버튼', 푸시는 '업로드', 풀은 '다운로드'입니다.

**Level.2:** 커밋은 변경 사항을 기록(확정)하는 것, 푸시는 내 기록을 깃허브(원격)로 보내는 것, 풀은 깃허브의 최신 코드를 내 컴퓨터로 가져오는 것입니다.

**Level.3:** 로컬 저장소에 스냅샷을 저장(Commit)하고, 원격 저장소에 동기화(Push/Pull)하는 명령어입니다.

```bash
git add .                    # 변경사항 스테이징
git commit -m "버그 수정"     # 커밋 (로컬에 저장)
git push origin main         # 푸시 (깃허브에 업로드)
git pull origin main         # 풀 (깃허브에서 다운로드)
```

**한줄 요약:** "작업 끝났으면 커밋하고 푸시해줘"라고 하면 됩니다.

### 1-6. 세상에 내보내기 (Deploy)

내 컴퓨터 밖으로 서비스를 내보내는 법

#### 로컬 (Local) vs 호스팅 (Hosting)

**Level.1:** 로컬은 내 방 컴퓨터, 호스팅은 인터넷상의 월세방(서버)을 빌리는 것입니다.

**Level.2:** 로컬은 개발자 개인 PC 환경(localhost), 호스팅은 24시간 켜져 있는 서버 공간을 임대해 주는 서비스입니다.

**Level.3:** 로컬은 개발 및 테스트 환경(Dev environment), 호스팅은 실제 서비스 운영을 위한 인프라 제공 서비스(AWS, Vercel 등)입니다.

```
로컬:    http://localhost:3000        (나만 볼 수 있음)
호스팅:  https://myapp.vercel.app     (전세계 누구나 접속 가능)
```

**한줄 요약:** "로컬에서 잘 되면 호스팅 서버에 올려줘"라고 하세요.

#### 도메인 (Domain) & 배포 (Deploy)

**Level.1:** 도메인은 '집 주소(example.com)', 배포는 인테리어를 마친 집을 사람들에게 공개하는 '오픈식'입니다.

**Level.2:** 도메인은 숫자로 된 IP 주소를 사람이 읽기 쉬운 문자로 바꾼 것, 배포는 만든 코드를 실제 서버로 옮겨 사용자가 접속 가능하게 만드는 과정입니다.

**Level.3:** DNS를 통해 IP와 도메인을 연결하며, CI/CD 파이프라인을 통해 프로덕션 환경으로 코드를 릴리즈(배포)합니다.

```bash
# Vercel에 배포하기
vercel --prod

# 배포 완료 후
✅ Deployed to https://my-awesome-app.vercel.app
```

**한줄 요약:** "배포가 완료되면 연결된 도메인 주소를 알려줘"라고 하세요.

## 2. 에이전틱 코딩(Vibe Coding) 프로세스

### 1. 기획 및 요구사항 정의 (Ideation)

**설명:** 코드를 직접 짜는 것이 아니라, AI에게 '무엇을 만들고 싶은지' 명확한 의도(Vibe)를 전달하는 가장 중요한 첫 단계입니다. 개발 지식보다는 서비스의 논리적인 흐름과 사용자의 경험을 설명하는 것이 핵심입니다.

**예시:**

```
"사용자가 '기분'을 입력하면 그에 맞는 음악을 추천해주는 웹사이트를 만들어줘.
디자인은 다크 모드에 네온 컬러를 써서 힙한 분위기를 내주고,
추천 결과는 유튜브 링크로 바로 연결되게 해줘."
```

**부연 설명:** 비개발자가 코딩에 실패하는 가장 큰 이유는 기술이 부족해서가 아니라, AI에게 무엇을 시킬지 모호하게 말하기 때문입니다. 단순히 "음악 추천 사이트 만들어줘"라고 하면 AI는 가장 일반적이고 재미없는 결과를 내놓습니다. 어떤 기능이 필요한지(로그인, 결제, 게시판 등), 어떤 디자인 스타일을 원하는지, 주 사용자는 누구인지 구체적으로 묘사해야 합니다. 마치 건축가에게 설계도를 말로 설명해주듯 구체적일수록 수정 횟수가 획기적으로 줄어듭니다.

**한줄 요약:** AI에게 '어떻게'가 아니라 '무엇'을 만들지, 최대한 구체적인 상황극을 하듯 설명하세요.

### 2. 생성 및 구현 (Generation)

**설명:** AI 에이전트(클로드코드, 안티그래비티 등)가 사용자의 지시를 받아 실제 프로그래밍 언어로 코드를 작성하고 파일을 생성하는 단계입니다. 사용자는 키보드를 치는 것이 아니라 감독관이 됩니다.

**예시:**

```bash
(AI에게 명령) "방금 기획한 기분 기반 음악 추천 로직을 Next.js로 짜고,
필요한 컴포넌트 파일을 생성해. 스타일은 Tailwind CSS를 써서 적용해줘."
```

**부연 설명:** 이 단계에서 AI는 순식간에 수십 개의 코드 파일을 생성하고, 필요한 라이브러리를 설치하며, 폴더 구조를 정리합니다. 사용자는 AI가 생성하는 파일명이나 폴더 구조를 보면서 내가 의도한 대로 만들어지고 있는지 확인만 하면 됩니다. AI가 멈추거나 모호한 점을 되물어볼 수 있는데, 당황하지 말고 상사가 직원에게 업무 지시를 내리듯 방향을 정해주면 됩니다. (예: "그건 A 방식으로 해")

**한줄 요약:** AI는 당신의 손과 발입니다. 팔짱 끼고 모니터를 보며 AI가 일하는 것을 감독하세요.

### 3. 검증 및 수정 (Iteration)

**설명:** 만들어진 결과물을 실제로 실행해보고, 오류를 고치거나 부족한 기능을 더하는 '대화의 반복' 단계입니다.

**예시:**

```
"방금 만든 화면에서 모바일로 보니까 글씨가 깨져.
그리고 추천 버튼이 작동을 안 하는데 에러 로그 확인해서 고쳐줘.
에러 메시지는 이거야: Error: Button is not defined..."
```

**부연 설명:** 개발 과정에서 에러는 필연적입니다. 비개발자는 빨간색 에러 메시지를 보면 겁을 먹지만, 에이전틱 코딩에서는 그 에러 메시지가 AI에게 줄 '먹이'가 됩니다. 에러 로그를 그대로 복사해서 AI에게 던져주면, AI는 원인을 분석하고 스스로 코드를 수정합니다. "디자인이 좀 촌스러운 것 같아" 같은 추상적인 피드백도 가능합니다. 한 번에 완벽한 결과물을 기대하기보다, 찰흙으로 도자기를 빚듯이 AI와 계속 대화하며 결과물을 다듬어 나가는 과정이 바로 이 단계의 핵심입니다.

**한줄 요약:** 에러 메시지는 내 문제가 아닙니다. 그대로 복사해서 AI에게 던지고 '고쳐(Fix it)'라고 말하세요.

---

<AgenticProcessDiagram />

### 🔄 프로세스 플로우 다이어그램

```mermaid
graph TD
    A[💡 1. 기획 및 요구사항 정의] --> B{명확한가?}
    B -->|Yes| C[🤖 2. 생성 및 구현<br/>AI가 코드 작성]
    B -->|No| A1[구체화하기<br/>- 기능 명세<br/>- 디자인 스타일<br/>- 사용자 시나리오]
    A1 --> A

    C --> D[🧪 3. 검증 및 수정<br/>실행 & 테스트]

    D --> E{완성도?}
    E -->|에러 발생| F[에러 로그 복사]
    E -->|기능 부족| G[추가 요구사항 작성]
    E -->|디자인 수정| H[UI/UX 피드백]
    E -->|완료!| I[🎉 배포<br/>Deploy]

    F --> C
    G --> C
    H --> C

    I --> J[✅ 프로덕션 완료]

    style A fill:#e1f5ff
    style C fill:#fff4e1
    style D fill:#ffe1f5
    style I fill:#e1ffe1
    style J fill:#90EE90
```

**다이어그램 읽는 법:**
- 🔷 **파란색**: 기획 단계 (사람의 역할)
- 🔶 **주황색**: 구현 단계 (AI의 역할)
- 🔸 **분홍색**: 검증 단계 (사람 + AI 협업)
- 🟢 **초록색**: 완료 단계

**핵심 인사이트:**
1. **반복이 정상입니다** - 한 번에 완성되는 프로젝트는 없습니다
2. **에러는 진행의 증거** - 에러가 나온다는 것은 AI가 뭔가 시도했다는 의미
3. **대화가 곧 개발** - AI와의 채팅 기록이 바로 개발 문서가 됩니다

---

### 📊 단계별 소요 시간 (평균)

| 단계 | 초보자 | 중급자 | 고급자 |
|------|--------|--------|--------|
| **기획 및 요구사항** | 30-60분 | 20-30분 | 10-15분 |
| **생성 및 구현** | 5-10분 (AI) | 3-5분 (AI) | 2-3분 (AI) |
| **검증 및 수정** | 1-3시간 | 30분-1시간 | 15-30분 |
| **반복 횟수** | 5-10회 | 3-5회 | 1-3회 |

**💡 Tip:** 초보자가 시간을 절약하는 방법은 "빠른 구현"이 아니라 "명확한 기획"입니다!

---

## 3. 에이전틱 코딩 툴

### 3-1. 안티그래비티 (Antigravity)

#### 안티그래비티 소개

**설명:** 웹 기반 AI 코딩 도구의 대표적인 예시로, 시각적인 인터페이스(GUI)가 뛰어나 초보자가 접근하기 가장 좋습니다.

**⚠️ 중요**: "안티그래비티"는 개념적 예시입니다. 실제로는 다음 서비스를 사용하세요:

**추천 웹 기반 IDE:**

| 서비스 | URL | 특징 | AI 지원 |
|--------|-----|------|---------|
| **StackBlitz** | stackblitz.com | 빠른 시작, 웹 특화 | Copilot 연동 |
| **Replit** | replit.com | 다양한 언어 지원 | Ghostwriter AI |
| **CodeSandbox** | codesandbox.io | React/Vue 특화 | AI 코드 완성 |
| **Google IDX** | idx.dev | Google 통합 | Gemini AI |

**예시 (StackBlitz 기준):**
1. `stackblitz.com` 접속
2. "New Project" → "Next.js" 선택
3. 우측 AI 채팅에서 "To-Do 리스트 만들어줘" 입력
4. 실시간 프리뷰로 결과 확인

**부연 설명:** 웹 기반 IDE는 복잡한 터미널 명령어보다는 눈에 보이는 화면을 중시합니다. 화면 왼쪽에는 파일 탐색기, 가운데는 코드 에디터, 오른쪽에는 AI 채팅창과 웹 프리뷰가 통합되어 있습니다. 특히 Gemini나 Copilot 같은 AI 모델을 사용하여 긴 문맥을 잘 이해하며, 웹사이트를 만들 때 내가 만든 결과물을 실시간으로 눈으로 확인하면서 수정할 수 있다는 점이 가장 큰 장점입니다. 설치 과정에서의 스트레스를 받기 싫은 분들에게 최적입니다.

**한줄 요약:** 설치가 귀찮고, 만드는 과정을 눈으로 보면서 하고 싶다면 웹 기반 IDE를 선택하세요.

#### 웹 기반 IDE 시작하기 (Mac/Windows)

**설명:** 별도의 설치 파일(exe, dmg)을 다운로드할 필요 없이 웹 브라우저를 통해 클라우드 환경에서 실행됩니다.

**실전 가이드 (StackBlitz 예시):**

**Step 1: 접속 및 로그인**
```
1. stackblitz.com 접속
2. GitHub 계정으로 로그인 (추천)
   또는 이메일 가입
3. 무료 티어: 즉시 사용 가능
```

**Step 2: 프로젝트 생성**
```
1. 홈 화면에서 "New Project" 클릭
2. 템플릿 선택:
   - Next.js (웹사이트 추천)
   - React (앱 UI)
   - Node.js (서버/API)
   - Static (간단한 HTML)
```

**Step 3: AI 활용**
```
1. 우측 상단 AI 아이콘 클릭
2. "Copilot" 또는 "AI Assistant" 활성화
3. 채팅창에 원하는 기능 입력
```

**대안 서비스 빠른 시작:**

| 서비스 | 시작 링크 | 로그인 |
|--------|----------|--------|
| **Replit** | replit.com/~new | Google/GitHub |
| **CodeSandbox** | codesandbox.io/s | GitHub |
| **Google IDX** | idx.dev | Google 계정 |

**부연 설명:** 내 컴퓨터의 성능(램, CPU)이 낮아도 상관없습니다. 모든 작업이 클라우드의 고성능 컴퓨터에서 이루어지기 때문입니다. 다만 인터넷 연결은 필수입니다. 프로젝트를 시작할 때 'Blank(빈 프로젝트)'를 고르거나 'Next.js', 'Python' 같은 템플릿을 고를 수 있는데, 비개발자라면 만들고 싶은 서비스와 가장 유사한 템플릿을 선택하거나 AI에게 추천해달라고 하는 것이 좋습니다.

**무료 티어 제한:**
- StackBlitz: 무제한 퍼블릭 프로젝트
- Replit: 월 10시간 무료
- CodeSandbox: 퍼블릭 샌드박스 무제한

**한줄 요약:** 다운로드 없이 크롬 브라우저만 열면 바로 시작할 수 있습니다.

#### 안티그래비티 기초 셋업

**설명:** AI에게 내 프로젝트의 성격과 역할을 부여하여, 나를 위한 맞춤형 개발자로 세팅하는 과정입니다.

**예시:** 채팅창 우측 상단 설정(또는 Rules)에 입력:

```
"나는 코딩을 모르는 기획자야. 이 프로젝트는 여행 사진을 기록하는 블로그야.
모든 코드는 초보자도 이해하기 쉽게 주석을 달아줘."
```

**부연 설명:** 프로젝트를 처음 켰을 때 AI 패널 설정이나 rules 파일에 프로젝트의 대전제를 입력해야 합니다. 내가 사용하는 언어(한국어), 내가 만들고 싶은 서비스의 정의, AI가 지켜야 할 태도(친절하게, 혹은 전문가스럽게) 등을 미리 설정해두면 작업 내내 일관된 답변을 받을 수 있습니다. 또한, 사용할 기술 스택(React, Firebase 등)을 미리 지정해주면 AI가 불필요한 고민 없이 바로 작업에 착수할 수 있어 효율적입니다.

**한줄 요약:** 첫 대화에서 '내가 누구고', '무엇을 만들 것이며', '너는 어떤 태도를 취해야 하는지' 선언하세요.

#### 안티그래비티 명령어

**설명:** 채팅창에 입력하는 자연어 명령 외에, 특정 파일이나 코드 블록을 AI에게 인식시키는 기능입니다.

**예시:**

- `@Codebase`: "내 프로젝트 전체 파일을 다 읽고 대답해줘."
- `@File`: 특정 파일만 콕 집어서 질문할 때 사용 (예: @Login.js 이거 수정해줘)

**부연 설명:** 안티그래비티의 채팅창에서 골뱅이(@)를 입력하면 마법 같은 일이 일어납니다. @Docs를 선택하면 공식 문서를 참고하고, @Web을 선택하면 인터넷 검색 결과를 반영합니다. 비개발자는 파일 위치를 잘 모를 수 있으므로, 그냥 @Codebase를 습관적으로 붙여서 질문하면 AI가 알아서 전체 프로젝트를 뒤져서 관련 있는 파일을 찾아 수정해 줍니다. 단축키 Ctrl+I (또는 Cmd+I)를 눌러서 코드 중간에 바로 명령을 내릴 수도 있습니다.

**한줄 요약:** 명령할 때 습관적으로 '@Codebase'를 붙이세요. AI가 전체 지도를 보고 길을 찾습니다.

#### 안티그래비티 스킬 (Skills)

**설명:** 안티그래비티 에이전트가 코딩 외에 인터넷 검색, 이미지 생성 등 외부 도구를 사용할 수 있게 해주는 확장 기능입니다.

**예시:** 스킬 설정에서 'Google Search'와 'Image Gen'을 활성화 → "요즘 유행하는 여행 사이트 디자인 찾아보고, 로고 이미지도 만들어줘."

**부연 설명:** 단순히 코드를 짜는 것을 넘어, 자료 조사나 리소스 생성까지 맡길 수 있습니다. `.agent/skills` 폴더에 `skill.md` 파일을 만들어서 나만의 스킬을 정의할 수도 있습니다. 예를 들어 "매일 아침 9시에 뉴스 헤드라인을 가져오는 스킬"을 정의해두면, 에이전트가 그 스킬을 사용해 기능을 구현합니다. 기본적으로 제공되는 검색 스킬만 잘 활용해도 기획 단계에서 큰 도움을 받을 수 있습니다.

**한줄 요약:** AI에게 '구글링 능력'과 '그림 그리는 능력'을 스위치 켜듯이 장착해주세요.

#### 안티그래비티 활용 꿀팁

**설명:** '에이전트 매니저'와 '프리뷰' 기능을 적극적으로 활용하여 시각적인 피드백을 즉시 반영하는 것입니다.

**예시:** 코드를 수정하자마자 오른쪽 프리뷰 창을 보고 "버튼 색깔이 너무 칙칙해. 좀 더 밝은 파란색으로 바꿔줘"라고 말하기.

**부연 설명:** 안티그래비티는 여러 개의 프로젝트를 동시에 관리하는 '에이전트 매니저' 기능이 있습니다. 기획용 에이전트, 디자인용 에이전트, 코딩용 에이전트를 따로 띄워두고 서로 협업하게 시킬 수 있습니다. 또한, 프리뷰 기능이 강력해서 코드를 전혀 몰라도 화면만 보고 "여기 고쳐줘", "저기 옮겨줘"라고 손가락질하듯 수정 요청을 할 수 있습니다. 초보자에게는 이 시각적 피드백 루프가 학습과 결과물 완성에 결정적인 역할을 합니다.

**한줄 요약:** 화면을 보면서 '이거 고쳐줘'라고 말하는 것이 가장 빠르고 확실한 방법입니다.

### 3-2. 클로드코드 (Claude Code)

#### 클로드코드 소개

**설명:** 앤스로픽(Anthropic)에서 만든 터미널(CLI) 기반의 고성능 AI 코딩 에이전트입니다. 논리적 추론 능력이 현존 AI 중 최상위권입니다.

**예시:** 검은색 화면(터미널)에서 텍스트로만 대화하며, 복잡한 서버 로직이나 데이터 분석, 버그 수정을 처리합니다.

**부연 설명:** 화려한 버튼이나 창이 없습니다. 오직 텍스트 명령으로만 소통하지만, 그만큼 속도가 빠르고 정확합니다. 마우스를 쓸 필요 없이 키보드만으로 모든 개발 과정을 제어할 수 있어 "진짜 해커"가 된 기분을 느낄 수 있습니다. 특히 복잡한 문제 해결 능력이나 긴 코드를 이해하는 맥락(Context) 유지 능력이 탁월하여, 단순한 웹사이트를 넘어 복잡한 서비스나 자동화 툴을 만들 때 가장 추천되는 도구입니다.

**한줄 요약:** 화려함은 빼고 지능만 남겼습니다. 진짜 개발자처럼 일하는 천재 AI 파트너입니다.

#### 클로드코드 설치 (Mac/Window)

**설명:** npm(노드 패키지 매니저) 명령어를 통해 터미널에서 한 줄의 명령어로 설치합니다.

**예시:**

1. Node.js 홈페이지에서 설치
2. 터미널 열고 입력: `npm install -g @anthropic-ai/claude-code`

**부연 설명:** 설치 과정이 텍스트 기반이라 비개발자에게는 진입 장벽처럼 느껴질 수 있습니다. 하지만 딱 두 단계입니다. 첫째, 내 컴퓨터에 자바스크립트를 실행할 수 있는 환경(Node.js)을 깐다. 둘째, 그 환경 위에 클로드 코드를 깐다. 맥 사용자는 터미널, 윈도우 사용자는 PowerShell을 관리자 권한으로 열어서 진행하면 됩니다. 설치가 완료되면 어디서든 `claude`라고 치면 AI가 튀어나옵니다.

**한줄 요약:** 겁먹지 말고 Node.js 설치 후, 터미널에 명령어 한 줄만 복사해서 붙여넣으세요.

#### 클로드코드 기초 셋업

**설명:** 설치 후 앤스로픽 계정으로 로그인하고, 작업할 폴더를 연결하는 과정입니다.

**예시:**

```bash
# 터미널에 입력
claude login                    # 브라우저 인증
mkdir my-project               # 폴더 생성
cd my-project                  # 폴더 진입
claude                         # 실행
```

**부연 설명:** 로그인은 최초 1회만 하면 됩니다. 중요한 것은 '폴더 위치'입니다. 클로드 코드는 현재 터미널이 위치한 폴더를 자신의 '작업실'로 인식합니다. 따라서 엉뚱한 곳에서 실행하지 않도록, 항상 `cd` 명령어로 내가 작업할 폴더로 이동한 뒤에 `claude`를 실행해야 합니다. 실행하면 "무엇을 도와드릴까요?"라고 묻는데, 이때부터 한국어로 대화를 시작하면 됩니다.

**한줄 요약:** 로그인하고, 작업할 폴더로 들어가서, 'claude'라고 이름을 부르면 준비 끝입니다.

#### 클로드코드 명령어

**설명:** 대화창에서 AI의 기억을 관리하거나, 특정 모드로 진입하기 위해 사용하는 슬래시(/) 명령어입니다.

**예시:**

- `/compact`: "지금까지 대화 내용 요약해서 기억 용량 좀 확보해."
- `/bug`: "방금 네가 짠 코드에서 에러 났어. 고쳐줘."

**부연 설명:** 그냥 말로 해도 되지만, 명령어를 쓰면 훨씬 효율적입니다. 특히 `/compact`는 필수입니다. 대화가 길어지면 AI가 이전 내용을 까먹거나(토큰 초과), 비용이 비싸집니다. 작업을 하나 끝낼 때마다 `/compact`를 입력하면, AI가 "아, 지금까지 이런 일을 했지"라고 요약하며 뇌 용량을 비웁니다. `/bug` 명령어를 쓰면 AI가 스스로 디버깅 모드로 전환되어 문제 해결에 집중합니다.

**한줄 요약:** 대화가 길어지면 '/compact'를 쳐서 AI의 뇌를 정리해주고 비용을 아끼세요.

#### 클로드코드 스킬 (Skills)

**설명:** 클로드코드에게 반복적인 업무 수행 방법이나 외부 도구 사용법을 가르치는 '업무 매뉴얼'입니다. "Skill은 Claude에게 특정 작업 방법을 가르치는 마크다운 파일"로, 패턴을 학습하고 자동으로 적용합니다.

**저장 위치:**
```bash
# 사용자 레벨 (모든 프로젝트에 적용)
~/.claude/skills/your-skill-name/SKILL.md

# 프로젝트 레벨 (특정 프로젝트만)
.claude/skills/your-skill-name/SKILL.md
```

**SKILL.md 기본 구조:**
```yaml
---
name: code-review-standards
description: PR 검토나 개선사항 제안 시 팀 표준 적용
---

# 코드 리뷰 표준
1. 가독성: 명확한 변수명 사용
2. 성능: O(n) 이하 복잡도 유지
3. 테스트: 새 함수마다 유닛테스트 작성
4. 문서화: 복잡한 로직에 주석 필수
```

**핵심 포인트:**
- **Description이 중요**: Claude가 Skill 적용 여부를 결정할 때 사용
- **컨텍스트 절약**: 초기에는 이름과 설명만 로드(~100토큰), 필요할 때만 전체 로드
- **참고 파일 추가 가능**: 긴 자료는 별도 파일로 분리

**활용 사례:**
- 커밋 메시지 컨벤션 (Conventional Commits)
- 데이터베이스 쿼리 패턴
- API 문서 형식
- 회의 노트 템플릿
- 개인 워크플로우

**한줄 요약:** 자주 시키는 일은 'SKILL.md'로 만들어서 AI에게 장착시키세요. 업무 효율이 10배 오릅니다.

#### 클로드코드 서브에이전트 (Sub-agents)

**설명:** "Subagent는 자체 컨텍스트 윈도우, 시스템 프롬프트, 도구 권한을 가진 독립적인 Claude 인스턴스"입니다. 메인 AI(팀장)가 작업을 특화된 하위 AI(팀원)에게 위임합니다.

**필요 이유:**
컨텍스트가 45%를 넘으면 품질 저하 → Subagent 사용으로 메인 대화를 깨끗하게 유지

**내장 Subagents:**

| 이름 | 역할 | 도구 권한 | 사용 시기 |
|------|------|---------|---------|
| **Explore** | 읽기 전용 코드 분석 | Read, Grep, Glob | 코드 이해 필요 |
| **Plan** | 계획 전 조사 | Read, Grep, Glob | 구현 전략 수립 |
| **General-purpose** | 탐색+액션 모두 | 모든 도구 | 복잡한 다단계 작업 |

**커스텀 Subagent 생성 예시:**
```yaml
---
name: security-reviewer
description: 보안 취약점 검토 (인증, 인젝션, 데이터 노출)
tools: Read, Grep, Glob
---

당신은 보안 중심의 리뷰어입니다:
1. 인증/권한 격차 확인
2. 인젝션 취약점 검사 (SQL, XSS 등)
3. 민감 데이터 노출 식별
4. 안전하지 않은 의존성 플래그

심각도별 분류: critical, high, medium, low
```

**통신 워크플로우:**
```
1. 메인 에이전트 → 작업 식별
2. 메인 에이전트 → Subagent 호출 (프롬프트 포함)
3. Subagent → 독립 컨텍스트에서 실행
4. Subagent → 요약 반환 (전체 아님!)
5. 메인 에이전트 → 결과 통합
```

**Subagent 체이닝 예시:**
```
탐색 단계: Explore → "3개 관련 파일 발견"
  ↓
구현 단계: Implementer → "2개 파일 수정 완료"
  ↓
테스트 단계: Test Runner → "12개 테스트 통과, 94% 커버리지"
```

**⚠️ 중요: 요약이 핵심**
Subagent는 전체 컨텍스트 대신 **핵심 요약만 반환**하므로 출력 형식을 명확히 지정해야 합니다.

**한줄 요약:** 컨텍스트 45% 넘으면 Subagent로 분산, 각자 전문 분야만 맡겨서 품질 향상시키세요.

#### 클로드코드 훅 (Hooks)

**설명:** 특정 이벤트가 발생하면 자동으로 반응하는 스크립트입니다. 반복적인 작업을 자동화하여 실수를 줄여줍니다.

**위치:**
```bash
~/.claude/hooks/          # 전역 훅
.claude/hooks/            # 프로젝트별 훅
```

**주요 Hooks 종류:**

| Hook | 실행 시점 | 활용 예시 |
|------|---------|---------|
| **pre-commit** | 커밋 전 | 린트/포맷 자동 실행 |
| **post-save** | 파일 저장 후 | 테스트 자동 실행 |
| **on-error** | 에러 발생 시 | 에러 로깅 |
| **session-start** | 세션 시작 시 | 환경 설정 |

**예시 - pre-commit 훅:**
```bash
# .claude/hooks/pre-commit.sh
#!/bin/bash
echo "🔍 린트 검사 실행 중..."
npm run lint
if [ $? -ne 0 ]; then
  echo "❌ 린트 에러 발견. 커밋 취소."
  exit 1
fi
echo "✅ 린트 통과"
```

**한줄 요약:** Hooks로 린트, 테스트, 포맷을 자동화하면 AI가 알아서 챙겨줍니다.

#### 클로드코드 활용 꿀팁

**설명:** CLAUDE.md 파일과 이미지 인식을 활용하는 것입니다.

**예시:**

- **CLAUDE.md**: "이 프로젝트는 한국어로만 대답해"라고 적어두면 매번 말 안 해도 됨.
- **이미지 인식**: 내가 원하는 웹사이트 스크린샷을 찍어서 터미널에 붙여넣고 "이거랑 똑같이 만들어줘"라고 함.

**부연 설명:** CLAUDE.md는 AI에게 주는 '작업 지시서'입니다. 프로젝트 최상위 폴더에 이 파일을 만들어두면, AI가 작업을 시작할 때마다 이걸 먼저 읽습니다. 잔소리를 파일로 박제해두는 셈이죠. 또한 클로드코드는 이미지를 볼 수 있습니다. 디자인을 말로 설명하기 힘들 때, 참고할 이미지를 그냥 드래그 앤 드롭하면 기가 막히게 이해하고 코드로 구현해 줍니다.

**한줄 요약:** 'CLAUDE.md' 파일에 잔소리를 적어두고, 말로 설명하기 힘들면 그림을 보여주세요.

#### 클로드코드 플랜 모드 (Plan Mode)

**설명:** 코드를 바로 작성하지 않고, AI가 먼저 작업 계획을 수립하는 모드입니다. "생각하고 코딩하기(Think First)" 원칙을 실천합니다.

**예시:**
```bash
# 플랜 모드 진입
Shift + Tab + Tab (두 번 연속)

# 또는 명령어로
/plan "쇼핑몰 장바구니 기능 구현"
```

**부연 설명:** 무계획한 코딩은 디버깅 시간을 크게 증가시킵니다. 플랜 모드에서 Claude는 직접 코드를 작성하지 않고 다음을 수행합니다: 1) 요구사항 분석, 2) 필요한 파일 목록, 3) 구현 단계 정리, 4) 잠재적 문제점 식별. 계획이 승인되면 그대로 실행하면 됩니다. **"5분간의 계획 수립이 몇 시간의 디버깅을 절약합니다."**

**한줄 요약:** Shift + Tab 두 번으로 플랜 모드 진입, 코딩 전에 반드시 계획부터 세우세요.

#### CLAUDE.md 작성 4가지 원칙

**설명:** 프로젝트 루트의 CLAUDE.md 파일은 Claude가 세션 시작 시 가장 먼저 읽는 "프로젝트 헌법"입니다. 제대로 작성하면 매번 같은 설명을 반복하지 않아도 됩니다.

**4가지 황금 원칙:**

1. **간결성**: 150~200개 지시사항 제한 (시스템 프롬프트가 ~50개 차지)
2. **특화성**: 프로젝트 고유 내용만 (일반적인 설명 불필요)
3. **이유 포함**: "왜"를 명시하면 AI가 맥락 이해
4. **지속 업데이트**: 반복되는 실수는 즉시 문서화

**나쁜 vs 좋은 예시:**

```markdown
# ❌ 나쁜 예시
- TypeScript strict mode 사용
- 깔끔한 코드 작성
- 버그 없이 개발

# ✅ 좋은 예시
- 타입 관련 런타임 버그를 방지하기 위해 TypeScript strict mode 사용
- 팀원들이 빠르게 이해할 수 있도록 함수는 20줄 이내로 작성
- 프로덕션 환경에서 발생한 버그는 반드시 테스트 케이스 추가 후 수정
```

**실시간 업데이트 팁:**
```bash
# 대화 중 # 키 입력
# → Claude가 CLAUDE.md에 자동으로 지시사항 추가
```

**한줄 요약:** "이유"를 포함해서 작성하면 AI가 10배 더 똑똑해집니다.

#### 컨텍스트 윈도우 관리 (Context Management)

**설명:** Claude의 기억 용량(컨텍스트)을 효율적으로 관리하는 방법입니다. 컨텍스트가 가득 차면 AI가 멍청해집니다.

**용량 가이드:**
- 전체 한계: 200,000 토큰
- 품질 유지 범위: **20-40% 미만**
- ⚠️ 주의: 용량이 꽉 차기 전부터 품질이 저하됩니다

**품질 저하 신호:**
```
- 이전 대화 내용을 잊어버림
- 같은 질문을 반복함
- /compact 후에도 결과가 부진함
```

**관리 전략:**

| 전략 | 실행 방법 | 효과 |
|------|---------|------|
| **범위 제한** | 기능당 하나의 대화 세션 | 집중력 향상 |
| **외부 저장** | SCRATCHPAD.md에 계획 저장 | 메모리 절약 |
| **점진적 리셋** | /compact → /clear → 재입력 | 신선한 시작 |
| **완전 초기화** | /clear로 전체 대화 삭제 | 깨끗한 상태 |

```bash
# 컨텍스트 정리 순서
/compact          # 대화 요약
/clear           # 필요시 전체 삭제
# → 중요 정보만 다시 입력
```

**중요 특성:** Claude는 stateless(상태 비저장). 매 대화마다 제공된 정보만으로 작업합니다.

**한줄 요약:** 컨텍스트 40% 넘으면 /compact, 그래도 안 되면 /clear 후 재시작하세요.

#### 프롬프트 엔지니어링 3원칙

**설명:** "프롬프트 엔지니어링은 거창한 기술이 아닙니다. 그냥 명확하게 소통하는 것입니다."

**1) 구체성 (Specificity)**

```
❌ 모호: "인증 시스템 만들어줘"

✅ 구체적: "User 모델로 이메일/비밀번호 인증,
Redis 세션 (24시간 만료),
/api/protected 경로 보호 미들웨어 추가"
```

**2) 제약 조건 명시 (Constraints)**

```
"간단하게 유지해줘.
요청하지 않은 추상화는 추가하지 마.
가능하면 한 파일로 해줘."
```

**3) 배경 정보 제공 (Context)**

```
✅ 성능 중요: "모든 요청마다 실행되므로 빨라야 함"
✅ 빠른 개발: "나중에 버릴 프로토타입"
```

**AI의 역할 재정의:**
- AI는 개발자를 대체하지 않습니다
- AI도 실수합니다
- 결과물 검토 능력이 필수입니다

**나쁜 결과의 진짜 원인:**
- ❌ 모델 성능 부족 (거의 아님)
- ✅ 모호한 프롬프트 (대부분 이것)

**한줄 요약:** 구체성 + 제약 조건 + 배경 정보 = 원하는 결과

### 3-3. 오 마이 클로드코드 (Oh My Claude Code)

#### 오 마이 클로드코드 소개

**설명:** 클로드코드를 더 편하고 강력하게 쓰기 위해 개발자들이 만든 **오픈소스 확장팩(플러그인)**입니다.

**예시:** 순정 자동차에 튜닝을 해서 속도를 높이고 편의 기능을 추가하는 것과 같습니다. '오 마이 갓' 소리가 나올 정도로 편해서 붙은 이름입니다.

**부연 설명:** 클로드코드의 기본적인 기능에 더해, 자동으로 파일을 정리하거나 여러 에이전트를 동시에 부리는 기능이 추가되어 있습니다. 특히 '멀티 에이전트 오케스트레이션'을 비개발자도 쉽게 쓸 수 있도록 미리 세팅해둔 버전이라고 보시면 됩니다. 설치하면 `omc`라는 명령어로 더 강력한 기능들을 쓸 수 있게 됩니다.

**한줄 요약:** 클로드코드의 성능을 200% 끌어올리는 무료 튜닝팩입니다.

#### 오 마이 클로드코드 설치법

**설명:** 깃허브(GitHub)에서 코드를 다운로드 받아 설정합니다.

**예시:**

```bash
git clone https://github.com/.../oh-my-claudecode
./install.sh
```

**부연 설명:** 터미널에서 명령어를 입력해 설치합니다. 설치가 완료되면 클로드코드 실행 시 자동으로 로드되어 추가 기능이 활성화됩니다. 다소 복잡해 보일 수 있지만, 한 번 설치해두면 계속 쓸 수 있습니다.

**한줄 요약:** 깃허브 주소를 복사해서 터미널에 붙여넣고 설치하세요.

#### 오 마이 클로드코드 기초 셋업

**설명:** 확장팩이 제공하는 설정 파일을 내 입맛에 맞게 수정합니다.

**예시:** `config.json` 파일을 열어서 `auto_save: true` (자동 저장 켜기), `language: "ko"` (한국어 설정) 등으로 바꿉니다.

**부연 설명:** 기본 설정만 써도 훌륭하지만, 설정을 만지면 나만의 비서를 완벽하게 커스터마이징 할 수 있습니다. 예를 들어, 특정 모델(Opus, Sonnet)을 고정하거나, 토큰 사용량을 제한하는 등의 설정을 할 수 있습니다.

**한줄 요약:** 설정 파일에서 언어와 자동 저장 옵션만 켜도 충분합니다.

#### 오 마이 클로드코드 명령어

**설명:** 기존 클로드코드 명령어보다 더 짧고 강력한 단축 명령어를 제공합니다.

**예시:**

- `omc start`: 프로젝트 분석부터 기획안 작성까지 한 번에 실행
- `omc fix`: 현재 발생한 모든 에러를 자동으로 감지해서 수정 시도

**부연 설명:** 여러 단계의 작업을 명령어 하나로 압축해 둡니다. '딸깍' 한 번으로 많은 일을 처리할 수 있습니다. 특히 `omc fix` 같은 명령어는 에러가 났을 때 로그를 읽고 분석해서 고치는 과정을 한 방에 해결해 주기 때문에 비개발자에게는 구세주와 같습니다.

**한줄 요약:** 긴 명령어를 짧은 단축키로 바꿔주는 마법입니다.

#### 오 마이 클로드코드 활용 꿀팁

**설명:** '스웜(Swarm)' 모드를 활용하여 집단 지성을 이용하는 것입니다.

**예시:** `omc swarm "쇼핑몰 만들어줘"` → 기획자 AI, 디자이너 AI, 개발자 AI가 떼거지로 나와서 동시에 작업함.

**부연 설명:** 스웜 모드는 말 그대로 벌떼처럼 여러 에이전트가 동시에 달려들어 문제를 해결하는 모드입니다. 혼자 고민하는 것보다 여러 전문가가 동시에 토론하고 검증하기 때문에 결과물의 퀄리티가 비약적으로 상승합니다. 복잡한 프로젝트를 시작할 때 스웜 모드로 초안을 잡으면 실패 확률을 크게 줄일 수 있습니다.

**한줄 요약:** 'Swarm' 모드로 AI 군단을 소환해서 집단 지성으로 해결하세요.

### 3-4. 클로드코드 플러그인 (Plugins)

**설명:** 클로드코드의 기능을 확장해주는 추가 모듈입니다. 스마트폰 앱스토어처럼 필요한 기능만 골라서 설치할 수 있습니다.

**플러그인 명령어:**
```bash
# 마켓플레이스 검색
/plugin marketplace

# 플러그인 설치
/plugin install plugin-name

# 공식 Skills 플러그인 추가
/plugin marketplace add anthropics/skills

# 설치된 플러그인 목록
/plugin list

# 플러그인 제거
/plugin uninstall plugin-name
```

**인기 플러그인 예시:**
- **이미지 생성**: DALL-E, Midjourney 통합
- **데이터 분석**: Pandas, Matplotlib 자동 실행
- **문서 변환**: PDF, Excel, CSV 처리
- **코드 포매터**: Prettier, Black 자동 적용

**공식 리소스:**
- GitHub: `github.com/anthropics/claude-plugins-official`
- Skills 저장소: `github.com/anthropics/skills` (46.9k stars)
- 커뮤니티: `awesome-claude-skills` (5.5k stars)

**부연 설명:** 필요한 기능만 골라서 설치할 수 있어 가볍고 효율적입니다. 공식 마켓플레이스나 커뮤니티에서 유용한 플러그인을 찾아 설치하면 됩니다.

**한줄 요약:** /plugin marketplace로 앱스토어처럼 필요한 기능만 골라서 추가하세요.

### 3-5. 클로드코드 활용 레퍼런스

**설명:** 실제로 사람들이 무엇을 만들었는지 참고하여 내 프로젝트에 적용합니다.

**예시:**

- **개인용**: "매일 아침 뉴스 헤드라인을 3줄 요약해서 카톡으로 보내주는 봇"
- **업무용**: "엑셀 파일 100개를 읽어서 월별 매출 그래프를 그려주는 대시보드"
- **서비스**: "MBTI 기반으로 오늘 점심 메뉴를 추천해주는 웹사이트"

**부연 설명:** 거창한 앱이 아니어도 됩니다. 나의 반복되는 귀찮은 업무를 자동화하는 것부터 시작해보세요. 남들이 만든 프롬프트나 구조를 따라 해보는 것(Copy & Paste)이 가장 빠른 학습법입니다. 유튜브나 블로그에 공개된 '클로드코드 활용 사례'를 찾아보고, 그들이 쓴 명령어를 내 상황에 맞게 조금만 바꿔서 입력해 보세요.

**한줄 요약:** 남들이 만든 '자동화 봇'이나 '간단한 웹앱'을 그대로 따라 해보며 감을 익히세요.

## 4. 에이전트 오케스트레이션

### 1. 개념 (Concept)

**설명:** 한 명의 AI에게 모든 걸 시키는 게 아니라, **여러 AI에게 역할을 나눠주고 지휘(Orchestration)**하는 것입니다. 마치 오케스트라 지휘자가 되는 것과 같습니다.

**예시:**

- **매니저 AI**: 사용자 요청을 분석해서 업무를 분배함
- **코더 AI**: 실제 코드를 작성함
- **리뷰어 AI**: 작성된 코드를 검사하고 에러를 찾음

**부연 설명:** 한 AI가 다 하려고 하면 기억 용량(Context)이 초과되어 멍청해지거나, 앞뒤가 안 맞는 코드를 짤 확률이 높습니다. 역할을 나누면 각자 맡은 일만 잘하면 되므로 훨씬 똑똑하게 일합니다. 사용자는 직접 코딩을 하는 것이 아니라, 이들 AI 팀원들이 잘 일하고 있는지 조율하는 역할만 맡으면 됩니다.

**한줄 요약:** 당신은 '코더'가 아니라 AI 팀의 '팀장'이 되어야 합니다.

### 2. 프로세스 (Process)

**설명:** 사용자의 명령이 떨어지면 에이전트끼리 대화하며 결과물을 만들어내는 일련의 과정입니다.

**예시:**

```
사용자: "블로그 만들어줘."
  ↓
매니저 → 기획자: "블로그 기획안 짜와."
  ↓
기획자 → 코더: "이 기획안대로 코드 짜."
  ↓
코더 → 리뷰어: "코드 짰는데 검사해줘."
  ↓
매니저 → 사용자: "여기 완성된 블로그입니다."
```

**부연 설명:** 이 과정은 자동으로 이루어집니다. 사용자는 중간 과정에 일일이 개입할 필요 없이, 각 단계의 책임자(에이전트)가 승인한 결과물만 받아보면 됩니다. 만약 중간에 문제가 생기면 매니저 에이전트가 사용자에게 "이 부분은 어떻게 할까요?"라고 물어볼 것입니다. 이것이 진정한 의미의 '오토파일럿' 개발입니다.

**한줄 요약:** AI들끼리 회의하고 일하게 만든 뒤, 당신은 결과만 보고받으세요.

---

### 🏗️ 에이전트 오케스트레이션 아키텍처

```mermaid
graph TB
    subgraph "👤 사용자 레이어"
        USER[사용자<br/>"블로그 만들어줘"]
    end

    subgraph "🎯 매니저 레이어"
        MANAGER[매니저 에이전트<br/>Task 분배 & 조율]
    end

    subgraph "🤖 작업 에이전트 레이어"
        PLANNER[📋 Planner<br/>기획 & 요구사항]
        ARCHITECT[🏛️ Architect<br/>구조 설계]
        EXECUTOR[⚙️ Executor<br/>코드 작성]
        REVIEWER[🔍 Reviewer<br/>코드 검증]
        TESTER[🧪 Tester<br/>테스트 실행]
    end

    subgraph "📦 도구 레이어"
        GIT[Git<br/>버전관리]
        NPM[NPM<br/>패키지 설치]
        BUILD[Build<br/>빌드 시스템]
        DEPLOY[Deploy<br/>배포]
    end

    USER --> MANAGER

    MANAGER --> PLANNER
    MANAGER --> ARCHITECT
    MANAGER --> EXECUTOR
    MANAGER --> REVIEWER
    MANAGER --> TESTER

    PLANNER -.->|기획서| ARCHITECT
    ARCHITECT -.->|설계도| EXECUTOR
    EXECUTOR -->|코드| REVIEWER
    REVIEWER -.->|피드백| EXECUTOR
    REVIEWER -->|승인| TESTER

    EXECUTOR --> GIT
    EXECUTOR --> NPM
    TESTER --> BUILD
    TESTER --> DEPLOY

    MANAGER -->|최종 결과| USER

    style USER fill:#e1f5ff
    style MANAGER fill:#ffe1e1
    style PLANNER fill:#fff4e1
    style ARCHITECT fill:#fff4e1
    style EXECUTOR fill:#fff4e1
    style REVIEWER fill:#e1ffe1
    style TESTER fill:#e1ffe1
```

**아키텍처 설명:**

| 레이어 | 역할 | 특징 |
|-------|------|------|
| 👤 **사용자** | 최종 의사결정 | "무엇을" 만들지만 지시 |
| 🎯 **매니저** | 작업 분배 & 조율 | Context 관리, 에이전트 간 통신 |
| 🤖 **작업 에이전트** | 전문 작업 수행 | 각자 역할에 집중 (Single Responsibility) |
| 📦 **도구** | 실제 실행 | Git, NPM, Build 등 시스템 명령 |

---

### 🔄 실제 작동 시퀀스 예시

```mermaid
sequenceDiagram
    participant U as 👤 사용자
    participant M as 🎯 매니저
    participant P as 📋 Planner
    participant A as 🏛️ Architect
    participant E as ⚙️ Executor
    participant R as 🔍 Reviewer

    U->>M: "To-Do 앱 만들어줘"

    M->>P: 기획 요청
    P->>M: ✅ 기획서 (기능 명세)

    M->>A: 설계 요청 + 기획서
    A->>M: ✅ 아키텍처 (파일 구조)

    M->>E: 구현 요청 + 설계도
    E->>M: ✅ 코드 (10개 파일)

    M->>R: 검증 요청 + 코드
    R->>M: ❌ 3개 파일 에러 발견

    M->>E: 수정 요청 + 에러 리스트
    E->>M: ✅ 수정 완료

    M->>R: 재검증 요청
    R->>M: ✅ 모두 통과

    M->>U: 🎉 완성된 To-Do 앱
```

**시퀀스 읽는 법:**
- **실선 화살표 (→)**: 요청 (Request)
- **점선 화살표 (- -)**: 응답 (Response)
- **✅**: 성공
- **❌**: 실패 (재작업 필요)

---

### 3. 도구와 구현 (Implementation)

**설명:** 클로드코드의 '서브에이전트' 기능이나 '오 마이 클로드코드' 같은 툴을 이용해 실제 오케스트레이션을 구현하는 방법입니다.

**예시:** CLAUDE.md 파일이나 설정 파일에 "너는 기획자야", "너는 디자이너야"라고 역할을 적어두는 것만으로도 오케스트레이션이 시작됩니다.

**부연 설명:** 복잡한 코딩이 필요한 게 아닙니다. "누가 무엇을 할지" 글로 적어주는 것(Role Definition)이 구현의 핵심입니다. 안티그래비티의 경우 에이전트 매니저 화면에서 마우스 클릭 몇 번으로 에이전트를 추가하고 연결할 수 있습니다. 비개발자도 충분히 자신만의 'AI 개발팀'을 꾸릴 수 있습니다.

**한줄 요약:** AI에게 명찰(역할)을 달아주는 것이 오케스트레이션의 시작입니다.

### 4. 복합 시스템 구축 (Integrated System)

**통합 개념:**
**Skills (패턴) × Subagents (하위 작업) × MCP (외부 연동) = 강력한 시스템**

**각 컴포넌트 역할 분담:**

| 컴포넌트 | 역할 | 효과 |
|---------|------|------|
| **Skills** | 팀 컨벤션 저장 | 컨텍스트 부담 제거 |
| **Subagents** | 복잡 하위 작업 처리 | 메인 대화 깨끗함 유지 |
| **MCP** | 외부 서비스 연동 | 탭 전환 완전 제거 |

**실제 워크플로우 예시:**

```
1단계: MCP로 JIRA 이슈 검색
   ↓
2단계: Subagent(Explore)로 관련 파일 분석
   ↓
3단계: Skill로 팀 코드 리뷰 표준 적용
   ↓
4단계: Subagent(Implementer+Test-runner) 구현/검증
   ↓
5단계: MCP로 JIRA 이슈 완료 상태 업데이트
```

**핵심 철학:**
"Claude Code를 가장 잘 활용하는 사람들은 일회성 작업에 쓰지 않습니다. **재사용 가능한 구성 요소로 하는 시스템을 구축합니다.**"

**시작 팁:**
- 반복적으로 설명하는 것부터 Skill 하나 만들기
- 한 번에 모든 것을 시도할 필요 없음
- 투자하면 모든 후속 작업에서 효과 발생

**복합 효과:**
"Skills가 패턴을 인코딩하고, Subagents가 하위 작업을 처리하고, MCP가 서비스를 연결합니다. 함께라면 **사용할수록 더 좋아지는 시스템**을 구축합니다."

---

## 5. 실전 튜토리얼 (Step-by-Step)

### 🎓 튜토리얼 1: 첫 웹사이트 만들기 (30분)

**목표**: To-Do 리스트 웹앱 제작
**난이도**: ⭐ 초급
**준비물**: 클로드코드 설치 완료 또는 웹 기반 IDE 계정

#### Step 1: 프로젝트 시작

**클로드코드 사용 시:**
```bash
mkdir my-first-todo
cd my-first-todo
claude
```

**웹 기반 IDE 사용 시:**
```
1. StackBlitz 접속
2. "New Project" → "Next.js" 선택
3. 프로젝트명: my-first-todo
```

#### Step 2: AI에게 정확히 요청하기

**명확한 프롬프트 작성:**
```
"Next.js와 Tailwind CSS로 To-Do 리스트를 만들어줘.

기능 요구사항:
1. 할 일 추가 (input + 버튼)
2. 체크박스로 완료 표시
3. 삭제 버튼 (각 항목마다)
4. 완료된 항목은 취소선 처리
5. 로컬스토리지에 자동 저장

디자인:
- 심플하고 모던한 스타일
- 다크모드 지원
- 모바일 반응형

제약 조건:
- 한 파일로 작성 (app/page.tsx)
- 외부 라이브러리 최소화
- 주석으로 코드 설명"
```

**📸 화면 설명 (AI 응답 시):**

```
┌─────────────────────────────────────────┐
│ 💬 Claude Code                          │
├─────────────────────────────────────────┤
│ 네, To-Do 리스트를 만들어드리겠습니다.  │
│                                         │
│ 📝 Writing app/page.tsx...              │
│ ✅ Created 1 file                       │
│ 📦 Installing dependencies...           │
│ ✅ npm install completed                │
│                                         │
│ 생성된 파일:                            │
│ • app/page.tsx (234 lines)              │
│ • tailwind.config.js (updated)          │
│                                         │
│ 다음 명령으로 실행하세요:               │
│ $ npm run dev                           │
└─────────────────────────────────────────┘
```

**화면에서 확인할 요소:**
- ✅ **초록색 체크마크**: 작업 성공
- 📝 **Writing...**: 파일 생성 중
- 📦 **Installing...**: 패키지 설치 중
- 🔴 **Error**: 에러 발생 (빨간색)

---

#### Step 3: 실행 및 확인

**터미널에서:**
```bash
npm install
npm run dev
# 브라우저에서 localhost:3000 접속
```

**웹 IDE에서:**
- 자동으로 프리뷰 창에 표시됨

**📸 브라우저 화면 설명:**

```
┌─────────────────────────────────────────────────┐
│  localhost:3000                         🌙 ☀️  │
├─────────────────────────────────────────────────┤
│                                                 │
│            📝 My To-Do List                     │
│                                                 │
│  ┌───────────────────────────────────────────┐ │
│  │ 오늘 할 일을 입력하세요...         [추가] │ │
│  └───────────────────────────────────────────┘ │
│                                                 │
│  ☐  장보기                              [삭제] │
│  ☑  운동하기 (완료)                     [삭제] │
│  ☐  프로젝트 마무리                     [삭제] │
│                                                 │
│  전체: 3개 | 완료: 1개                          │
│                                                 │
└─────────────────────────────────────────────────┘
```

**화면 구성 요소:**
- 🌙 **다크모드 토글**: 오른쪽 상단 (해/달 아이콘)
- 📝 **제목**: 중앙 상단 (My To-Do List)
- ✏️ **입력창**: placeholder 텍스트 표시
- ➕ **추가 버튼**: 파란색 (hover 시 진해짐)
- ☐ **체크박스**: 클릭하면 ☑로 변경
- 📃 **할 일 텍스트**: 완료 시 취소선 처리
- ❌ **삭제 버튼**: 빨간색 (hover 시 진해짐)
- 📊 **카운터**: 하단에 통계 표시

**인터랙션 테스트:**
1. 입력창에 텍스트 입력 → Enter 또는 [추가] 클릭
2. 체크박스 클릭 → 취소선 + 회색 처리
3. 삭제 버튼 → 항목 사라짐
4. 새로고침(F5) → 로컬스토리지로 복원됨
5. 다크모드 토글 → 배경색 변경

---

#### Step 4: 수정 요청 예시

**디자인 조정:**
```
"버튼 색상을 파란색(#3B82F6)으로 바꿔줘"
"완료된 항목은 회색(#9CA3AF)으로 표시해줘"
"입력창 placeholder를 '오늘 할 일을 입력하세요'로 변경"
```

**기능 추가:**
```
"할 일 개수 카운터 추가해줘 (전체/완료)"
"전체 삭제 버튼 추가"
"중요 표시 기능 (별 아이콘)"
```

#### Step 5: 배포하기

**Vercel 배포 (무료):**
```bash
# 클로드코드에서
npm install -g vercel
vercel

# 또는 웹 IDE에서
# "Deploy" 버튼 클릭 → Vercel 연동
```

**🎉 완성!** 이제 URL로 전세계 어디서나 접속 가능합니다.

**예상 결과:**
```
✅ 입력창과 추가 버튼
✅ 할 일 목록 (체크박스 + 텍스트 + 삭제 버튼)
✅ 다크모드 토글
✅ 로컬스토리지 자동 저장
✅ 모바일에서도 잘 보임
```

---

### 🎓 튜토리얼 2: MCP로 GitHub 연동하기 (20분)

**목표**: Claude가 직접 GitHub 이슈 읽고 PR 만들기
**난이도**: ⭐⭐ 중급
**준비물**: GitHub 계정, 클로드코드

#### Step 1: GitHub 토큰 발급

```
1. github.com → Settings
2. Developer settings → Personal access tokens
3. Tokens (classic) → Generate new token
4. 권한 선택:
   ✅ repo (전체)
   ✅ read:org
5. 토큰 복사 (한 번만 보임!)
```

#### Step 2: MCP 서버 추가

```bash
claude mcp add --transport http github https://api.github.com/mcp \
  --header "Authorization: Bearer YOUR_TOKEN"
```

**또는 웹 앱에서:**
```
Settings → Connectors → Add GitHub → 토큰 입력
```

#### Step 3: Claude에게 명령

```
"내 GitHub 리포지토리 목록 보여줘"

"my-first-todo 리포의 열린 이슈 목록 가져와"

"이슈 #5번 내용 읽고 코드 수정해줘"

"수정한 내용으로 PR 만들어줘.
제목: Fix #5 - Add dark mode toggle
설명: 다크모드 토글 버튼 추가했습니다."
```

#### Step 4: 검증

```
1. GitHub에서 PR 생성 확인
2. 코드 변경 내용 확인
3. 머지 또는 추가 수정 요청
```

**🎉 탭 전환 없이 모든 작업 완료!**

---

### 🎓 튜토리얼 3: Subagent로 복잡한 프로젝트 (60분)

**목표**: 블로그 시스템 만들기 (기획 → 구현 → 테스트)
**난이도**: ⭐⭐⭐ 고급
**준비물**: 클로드코드, 오마이클로드 설치

#### Step 1: 플랜 모드로 시작

```bash
# Shift + Tab + Tab 누르기
/plan "마크다운 기반 블로그 시스템 만들기"
```

**Claude의 계획서 예시:**
```
1. 프로젝트 구조 설계
2. 마크다운 파서 구현
3. 블로그 포스트 목록 페이지
4. 개별 포스트 페이지
5. 다크모드 + 반응형 디자인
6. 검색 기능
```

#### Step 2: Subagent 활용

**Explore로 참고 코드 분석:**
```
"Next.js 블로그 예제 코드를 Explore Subagent로 분석해줘.
특히 마크다운 렌더링 부분을 집중적으로."
```

**Implementer로 구현:**
```
"Plan에 따라 파일 구조 만들고 기본 코드 작성해줘.
General-purpose Subagent 사용해서 진행."
```

**Test Runner로 검증:**
```
"작성한 코드에 대해 테스트 케이스 작성하고 실행해줘."
```

#### Step 3: Skill 생성

```yaml
# .claude/skills/blog-conventions/SKILL.md
---
name: blog-conventions
description: 블로그 포스트 작성 규칙
---

# 블로그 포스트 규칙
1. 파일명: YYYY-MM-DD-title.md
2. Frontmatter 필수:
   - title
   - date
   - tags
   - description
3. 이미지는 /public/images/ 저장
4. 코드 블록은 언어 명시
```

#### Step 4: 통합 및 배포

```bash
# 모든 기능 테스트
npm run dev

# 문제 발생 시
/compact
"에러 로그: [에러 메시지 붙여넣기]
Security Subagent로 보안 검토도 해줘"

# 배포
vercel --prod
```

**🎉 완성된 블로그 시스템!**

**학습 포인트:**
- ✅ 플랜 모드로 체계적 접근
- ✅ Subagent로 역할 분담
- ✅ Skill로 일관성 유지
- ✅ 단계별 검증

---

### 🎓 튜토리얼 4: Hook으로 자동화하기 (15분)

**목표**: 코드 저장 시 자동으로 포맷팅 + 테스트
**난이도**: ⭐⭐ 중급
**준비물**: 클로드코드 설치

#### Step 1: Hook 설정 파일 생성

```bash
# ~/.claude/hooks/post-save.sh 생성
mkdir -p ~/.claude/hooks
nano ~/.claude/hooks/post-save.sh
```

#### Step 2: Hook 스크립트 작성

```bash
#!/bin/bash
# post-save.sh - 파일 저장 후 자동 실행

FILE_PATH="$1"
FILE_EXT="${FILE_PATH##*.}"

echo "🪝 Hook 실행: $FILE_PATH"

# TypeScript/JavaScript 파일이면 포맷팅
if [[ "$FILE_EXT" == "ts" || "$FILE_EXT" == "tsx" || "$FILE_EXT" == "js" ]]; then
    echo "📝 Prettier로 포맷팅 중..."
    npx prettier --write "$FILE_PATH"

    echo "✅ ESLint 검사 중..."
    npx eslint "$FILE_PATH" --fix
fi

# 테스트 파일이면 테스트 실행
if [[ "$FILE_PATH" == *".test."* ]]; then
    echo "🧪 테스트 실행 중..."
    npm test "$FILE_PATH"
fi

echo "✨ Hook 완료!"
```

#### Step 3: 실행 권한 부여

```bash
chmod +x ~/.claude/hooks/post-save.sh
```

#### Step 4: Claude에게 Hook 등록

```
"post-save hook을 활성화해줘.
파일: ~/.claude/hooks/post-save.sh"
```

#### Step 5: 테스트

**코드 저장 시 자동 실행:**
```
1. 파일 수정 (예: app/page.tsx)
2. Claude에게 "저장해줘"
3. Hook 자동 실행 확인:
   ✅ Prettier 포맷팅
   ✅ ESLint 자동 수정
   ✅ 테스트 실행 (해당 시)
```

**📸 Hook 실행 화면:**

```
┌─────────────────────────────────────────┐
│ 💬 Claude Code                          │
├─────────────────────────────────────────┤
│ ✅ Saved app/page.tsx                   │
│                                         │
│ 🪝 Running post-save hook...            │
│ 📝 Prettier로 포맷팅 중...              │
│ ✅ Formatted                            │
│ ✅ ESLint 검사 중...                    │
│ ✅ No errors found                      │
│ ✨ Hook 완료!                           │
└─────────────────────────────────────────┘
```

**🎉 이제 저장할 때마다 자동으로 코드 정리!**

**활용 아이디어:**
- 📸 **pre-commit**: Git 커밋 전 자동 검증
- 🔒 **pre-push**: 푸시 전 보안 스캔
- 📊 **post-build**: 빌드 후 성능 분석
- 📧 **deploy-complete**: 배포 완료 시 슬랙 알림

---

### 🎓 튜토리얼 5: Ultrawork로 병렬 개발 (45분)

**목표**: E-커머스 사이트를 5개 에이전트가 동시에 제작
**난이도**: ⭐⭐⭐ 고급
**준비물**: 오마이클로드 설치

#### Step 1: 프로젝트 초기화

```bash
mkdir e-commerce
cd e-commerce
claude
```

#### Step 2: Ultrawork 모드 활성화

```
/oh-my-claudecode:ultrawork "쇼핑몰 만들어줘"
```

**Claude가 자동으로:**
```mermaid
graph LR
    A[요청 분석] --> B[Analyst]
    A --> C[Planner]

    B --> D[Architect]
    C --> D

    D --> E[Executor 1<br/>Frontend]
    D --> F[Executor 2<br/>Backend]
    D --> G[Executor 3<br/>Database]
    D --> H[Designer<br/>UI/UX]
    D --> I[Tester<br/>QA]

    E --> J[통합]
    F --> J
    G --> J
    H --> J
    I --> J

    J --> K[Verifier<br/>최종 검증]
```

#### Step 3: 상세 요구사항 제공

```
"쇼핑몰 상세 기획:

기능:
1. 상품 목록 (필터링, 정렬)
2. 상품 상세 페이지
3. 장바구니 (로컬스토리지)
4. 간단한 결제 폼 (실제 결제 X)
5. 관리자 페이지 (상품 추가/수정/삭제)

기술 스택:
- Next.js 14 (App Router)
- Tailwind CSS
- TypeScript
- Prisma + SQLite
- NextAuth (간단 인증)

디자인:
- 미니멀 모던
- 화이트 베이스 + 포인트 컬러 (블루)
- 모바일 우선 반응형"
```

#### Step 4: 병렬 작업 모니터링

**📸 Ultrawork 실행 화면:**

```
┌─────────────────────────────────────────────────────┐
│ 🚀 ULTRAWORK MODE ACTIVATED                         │
├─────────────────────────────────────────────────────┤
│                                                     │
│ 📋 Analyst     [████████] 100% ✅ 기획 완료        │
│ 🏗️ Planner     [████████] 100% ✅ 계획 완료        │
│ 🏛️ Architect   [████████] 100% ✅ 설계 완료        │
│                                                     │
│ ⚙️ Executor-1  [████▌   ] 65%  ⏳ Frontend 작업중  │
│ ⚙️ Executor-2  [██████  ] 75%  ⏳ API 구현중       │
│ ⚙️ Executor-3  [████████] 100% ✅ DB 스키마 완료   │
│ 🎨 Designer    [███████▌] 90%  ⏳ UI 컴포넌트      │
│ 🧪 Tester      [██      ] 25%  ⏳ 테스트 대기       │
│                                                     │
│ 생성된 파일: 47개 | 코드 라인: 3,247줄            │
│ 예상 완료: 8분 32초                                 │
└─────────────────────────────────────────────────────┘
```

**실시간 로그:**
```
[14:23:45] Executor-1: ✅ Created components/ProductCard.tsx
[14:23:47] Executor-2: ✅ Implemented /api/products route
[14:23:49] Designer:   ✅ Styled cart page with Tailwind
[14:23:52] Executor-3: ✅ Migrated Prisma schema
[14:23:55] Tester:     🧪 Running integration tests...
```

#### Step 5: 중간 개입 (필요시)

```
"Designer야, 상품 카드에 호버 효과 추가해줘"

"Executor-2야, API에 페이지네이션 추가 (limit: 20)"

"Tester야, 장바구니 테스트 우선으로 실행"
```

#### Step 6: 최종 검증

```
# 모든 에이전트 완료 후
┌─────────────────────────────────────────┐
│ 🔍 Verifier 최종 검증 중...             │
├─────────────────────────────────────────┤
│ ✅ 타입 체크 통과                       │
│ ✅ 빌드 성공                            │
│ ✅ 테스트 24/24 통과                    │
│ ✅ 보안 스캔 이상 없음                  │
│ ✅ 접근성 AAA 등급                      │
│                                         │
│ 🎉 프로젝트 완료!                       │
│ 📦 47 files, 3,247 lines               │
│ ⏱️  소요 시간: 12분 18초                │
└─────────────────────────────────────────┘
```

#### Step 7: 실행 및 확인

```bash
npm install
npm run dev
# localhost:3000 접속
```

**🎉 완성된 쇼핑몰 확인!**

**학습 포인트:**
- ✅ **병렬 처리**: 5개 에이전트가 동시 작업 (5배 빠름)
- ✅ **역할 분담**: 각 에이전트가 전문 분야 담당
- ✅ **실시간 조율**: 중간에 방향 수정 가능
- ✅ **품질 보증**: Verifier가 최종 검증

**Ultrawork vs 일반 모드 비교:**

| 항목 | 일반 모드 | Ultrawork 모드 |
|------|----------|---------------|
| **소요 시간** | 60-90분 | 12-15분 |
| **에이전트 수** | 1개 | 5-8개 |
| **병렬 처리** | ❌ 순차 | ✅ 동시 |
| **품질 검증** | 수동 | 자동 (Verifier) |
| **컨텍스트 관리** | 수동 (/compact) | 자동 분산 |

---

## 6. 문제 해결 가이드 (Troubleshooting)

### 🔧 자주 발생하는 문제와 해결법

#### 문제 1: "AI가 이상한 코드를 짜요"

**증상:**
- 요청한 것과 다른 결과
- 불필요한 복잡한 코드
- 작동하지 않는 기능

**원인**: 프롬프트가 모호하거나 컨텍스트 부족

**해결책:**

**Step 1: 구체적으로 다시 요청**
```
❌ 나쁜 예: "로그인 기능 만들어줘"

✅ 좋은 예:
"이메일/비밀번호 로그인 만들어줘.

요구사항:
- 이메일 형식 검증 (정규식 사용)
- 비밀번호 8자 이상, 영문+숫자 조합
- 로그인 실패 시 '이메일 또는 비밀번호가 틀렸습니다' 표시
- 성공 시 /dashboard로 리다이렉트
- Next.js API 라우트 사용
- bcrypt로 비밀번호 해싱

제약:
- 간단하게 유지
- 외부 라이브러리 최소화
- 주석 상세히"
```

**Step 2: CLAUDE.md에 규칙 추가**
```markdown
# CLAUDE.md
## 코드 작성 규칙
- 항상 간단한 방법 우선
- 요청하지 않은 추상화 금지
- 주석으로 설명 필수
- TypeScript strict mode 사용
```

**Step 3: 컨텍스트 초기화**
```bash
/compact
/clear  # 필요시
# → 핵심 정보만 다시 제공
```

---

#### 문제 2: "컨텍스트 초과 에러"

**증상:**
```
Error: Context window exceeded
또는
- AI가 이전 내용 잊어버림
- 같은 질문 반복
- 품질 급격히 저하
```

**원인**: 대화가 너무 길어져 200,000 토큰 초과 또는 45% 이상 사용

**즉시 해결:**
```bash
# 1단계: 요약
/compact

# 2단계: 확인
"지금까지 우리가 한 작업 요약해줘"

# 3단계: 필요시 초기화
/clear
```

**장기 해결:**
```markdown
1. CLAUDE.md 활용
   - 반복 설명 → 파일로 저장

2. SCRATCHPAD.md 사용
   - 긴 계획 → 외부 파일에 저장

3. Subagent 활용
   - 독립 작업 → Subagent에 위임

4. 작업 단위 분리
   - 기능별로 대화 새로 시작
```

**예방:**
```
✅ 작업 1개 완료 → /compact
✅ 큰 기능 → Subagent 사용
✅ 컨텍스트 40% → 경고
✅ 세션 종료 전 → 핵심 내용 저장
```

---

#### 문제 3: "npm install이 안 돼요"

**증상:**
```bash
npm ERR! code ENOENT
npm ERR! syscall open
npm ERR! path /package.json
```

**해결 체크리스트:**

**1. Node.js 설치 확인**
```bash
node -v
# v18.0.0 이상이어야 함

# 없으면 설치
# Mac: brew install node
# Windows: nodejs.org에서 다운로드
```

**2. package.json 확인**
```bash
ls -la
# package.json 파일 있는지 확인

# 없으면
npm init -y
```

**3. 권한 문제**
```bash
# Mac/Linux
sudo npm install

# Windows
# PowerShell을 관리자 권한으로 실행
```

**4. 캐시 삭제**
```bash
npm cache clean --force
rm -rf node_modules package-lock.json
npm install
```

**5. Claude에게 도움 요청**
```
"npm install 에러가 났어. 에러 로그:
[에러 메시지 전체 복사]

package.json 확인하고 문제 고쳐줘"
```

---

#### 문제 4: "MCP 서버 연결 실패"

**증상:**
```
Failed to connect to MCP server
Connection timeout
```

**해결 순서:**

**1. 기본 확인**
```bash
# 인터넷 연결 확인
ping google.com

# MCP 서버 목록 확인
claude mcp list
```

**2. 토큰 재발급**
```
GitHub 예시:
1. github.com → Settings
2. Personal access tokens
3. 기존 토큰 삭제
4. 새 토큰 발급 (repo, read:org 권한)
5. MCP 서버 재등록
```

**3. 방화벽 확인**
```bash
# Mac
시스템 환경설정 → 보안 및 개인 정보 보호 → 방화벽

# Windows
제어판 → Windows Defender 방화벽
```

**4. 수동 테스트**
```bash
# GitHub API 직접 테스트
curl -H "Authorization: Bearer YOUR_TOKEN" \
  https://api.github.com/user
```

**5. 재설치**
```bash
# MCP 서버 제거
claude mcp remove github

# 다시 추가
claude mcp add --transport http github \
  https://api.github.com/mcp \
  --header "Authorization: Bearer NEW_TOKEN"
```

---

#### 문제 5: "비용이 너무 많이 나와요"

**증상:**
- API 비용 급증
- 예상보다 높은 청구

**원인 분석:**
```
1. /compact 미사용 → 컨텍스트 재전송
2. Opus 모델 과다 사용
3. 큰 파일 반복 읽기
4. Subagent 미활용
```

**즉시 절약:**
```bash
# 1. 모델 변경
Settings → Default Model → Sonnet (Opus 대신)

# 2. 컨텍스트 관리
/compact  # 작업마다 실행

# 3. CLAUDE.md 활용
# 반복 설명 → 파일로 이동
```

**장기 절약 전략:**

| 전략 | 절약 효과 |
|------|---------|
| Haiku 사용 (간단 작업) | 90% ↓ |
| /compact 습관화 | 50% ↓ |
| CLAUDE.md 활용 | 40% ↓ |
| Subagent 분리 | 30% ↓ |
| 큰 파일 요약 | 60% ↓ |

**비용 모니터링:**
```bash
# Anthropic 콘솔
console.anthropic.com → Usage

# 예산 설정
Settings → Billing → Set budget alert
```

**무료 대안:**
```
1. GitHub Copilot ($10/월 정액)
2. Cursor ($20/월 정액)
3. 웹 IDE 무료 티어
```

---

#### 문제 6: "플랜 모드가 작동 안 해요"

**증상:**
- Shift + Tab + Tab 무반응
- /plan 명령어 인식 안 됨

**해결:**

**터미널 단축키 충돌 확인:**
```bash
# Mac: iTerm2 설정 확인
Preferences → Keys → Key Bindings
# Shift+Tab 매핑 제거

# Windows: 터미널 설정
Settings → Actions → Key bindings
```

**명령어로 대체:**
```bash
/plan "작업 내용"
```

**수동 플랜 모드:**
```
"코드 작성 전에 먼저 계획을 세워줘:
1. 필요한 파일 목록
2. 구현 단계
3. 잠재적 문제점
4. 테스트 방법"
```

---

## 7. 자주 묻는 질문 (FAQ)

### 📚 기초 질문

#### Q1: 정말 코딩을 몰라도 되나요?

**A:** 네! 하지만 다음은 알면 도움됩니다:

**필수 (꼭 필요)**:
- ✅ 기본 컴퓨터 사용법 (폴더, 파일)
- ✅ 인터넷 검색 능력
- ✅ 논리적 사고 (IF-THEN, 순서도)

**선택 (있으면 좋음)**:
- 📋 HTML/CSS 기초 (w3schools.com에서 1시간)
- 📋 명령어 입력 경험 (터미널 사용)
- 📋 GitHub 기본 개념

**학습 순서 추천:**
```
1주차: 가이드 읽기 + 용어 익히기
2주차: 웹 IDE로 첫 프로젝트
3주차: 클로드코드 설치 및 연습
4주차: 실전 프로젝트
```

---

#### Q2: 얼마나 걸리나요?

**프로젝트별 예상 시간:**

| 프로젝트 | 초보자 | 중급자 | 예시 |
|---------|--------|--------|------|
| **간단한 웹페이지** | 30분~1시간 | 10~20분 | 랜딩 페이지 |
| **블로그/포트폴리오** | 2~4시간 | 1~2시간 | 개인 블로그 |
| **To-Do/메모앱** | 3~5시간 | 1~3시간 | 간단한 SaaS |
| **관리자 대시보드** | 1~2일 | 4~8시간 | 데이터 시각화 |
| **쇼핑몰급** | 3~7일 | 1~3일 | 결제 연동 포함 |

**실제 사례:**
- "첫 To-Do 앱: 2시간 (AI 대화 + 수정)"
- "개인 블로그: 4시간 (디자인 + 배포)"
- "스타트업 MVP: 3일 (기획 + 구현 + 테스트)"

---

#### Q3: 비용은 얼마나 드나요?

**Claude API 가격 (2025년 기준):**

| 모델 | 입력 | 출력 | 용도 |
|------|------|------|------|
| **Haiku** | $0.25/1M | $1.25/1M | 간단한 작업 |
| **Sonnet** | $3/1M | $15/1M | 일반 개발 (추천) |
| **Opus** | $15/1M | $75/1M | 복잡한 로직 |

**실제 프로젝트 비용 예상:**

| 프로젝트 | Sonnet 기준 | Haiku 기준 |
|---------|------------|-----------|
| 간단한 앱 | $0.5~$2 | $0.1~$0.5 |
| 중간 규모 | $5~$20 | $1~$5 |
| 대규모 | $50+ | $10~$30 |

**절약 팁:**
```
💰 /compact 자주 사용 (50% ↓)
💰 Haiku로 시작 후 필요시 Sonnet
💰 CLAUDE.md로 반복 설명 제거
💰 Subagent로 작업 분리
```

**월정액 대안:**
- GitHub Copilot: $10/월
- Cursor: $20/월
- Replit Ghostwriter: $20/월

---

#### Q4: 어떤 걸 만들 수 있나요?

**✅ 가능한 것 (추천):**

**웹 애플리케이션:**
- 블로그, 포트폴리오
- To-Do 리스트, 메모앱
- 관리자 대시보드
- 랜딩 페이지
- SaaS MVP

**자동화 도구:**
- 데이터 스크래핑
- 파일 일괄 처리
- 리포트 자동 생성
- 이메일 자동 발송

**데이터 분석:**
- 엑셀 데이터 시각화
- 차트/그래프 생성
- 통계 분석 대시보드

**❌ 어려운 것 (비추천):**
- 3D 게임, VR/AR
- 모바일 네이티브 앱 (iOS/Android)
- 실시간 영상/음성 처리
- 하드웨어 제어 (임베디드)
- 블록체인 스마트 컨트랙트

**⚠️ 주의 필요:**
- 결제 시스템 (보안 중요)
- 개인정보 처리 (법적 검토 필요)
- 금융 서비스 (규제 많음)

---

#### Q5: 에러가 나면 어떡하죠?

**황금 공식: "복사 → 붙여넣기 → 고쳐달라"**

**Step 1: 에러 메시지 전체 복사**
```bash
# 터미널 에러
Error: Cannot find module 'next'
  at Function.Module._resolveFilename
  ...전체 복사...
```

**Step 2: Claude에게 전달**
```
"이 에러 고쳐줘:
[에러 메시지 전체 붙여넣기]

현재 상황:
- npm run dev 실행 중
- Next.js 프로젝트
- 방금 새 파일 추가함"
```

**Step 3: 해결 안 되면 초기화**
```bash
/compact
"여전히 같은 에러야. 처음부터 다시 접근해줘"

# 그래도 안 되면
/clear
"새로 시작할게. 프로젝트 목표는..."
```

**자주 발생하는 에러 빠른 해결:**

| 에러 | 빠른 해결 |
|------|---------|
| `Module not found` | `npm install` |
| `Port already in use` | 포트 변경 또는 프로세스 종료 |
| `Syntax error` | AI에게 에러 라인 보여주기 |
| `CORS error` | API 설정 확인 |

---

### 🛠️ 도구 선택

#### Q6: 웹 IDE vs 클로드코드, 뭘 써야 하나요?

**선택 플로우:**

```
Q: 완전 처음이신가요?
├─ Yes → 웹 IDE (StackBlitz 추천)
│   이유: 설치 불필요, 시각적
│
└─ No → Q: 복잡한 로직 다룰 예정?
         ├─ Yes → 클로드코드
         │   이유: 더 강력, 정확
         │
         └─ No → 웹 IDE
             이유: 빠르고 편함
```

**비교:**

| 기준 | 웹 IDE | 클로드코드 |
|------|--------|-----------|
| 시작 속도 | 즉시 | 설치 필요 (10분) |
| 학습 곡선 | 완만 | 약간 가파름 |
| 성능 | 보통 | 우수 |
| 비용 | 제한적 무료 | 사용량 과금 |
| 오프라인 | ❌ | ✅ (일부) |

---

#### Q7: 무료로 할 수 있나요?

**완전 무료**: 거의 불가능 (API 비용 발생)

**저렴하게 (월 $5 이하)**:
```
1. 웹 IDE 무료 티어
   - StackBlitz (무제한 퍼블릭)
   - Replit (10시간/월)

2. 클로드코드 + Haiku 모델
   - 간단한 프로젝트: $1~2
   - /compact 자주 사용

3. 월정액 대안
   - GitHub Copilot: $10/월
   - Cursor: $20/월
```

**학생이라면**:
- GitHub Student Pack (무료)
- Replit 교육용 (무료)
- DigitalOcean 크레딧 ($200)

---

### 🎓 고급 질문

#### Q8: Subagent는 언제 써야 하나요?

**사용 시기 (신호):**

**1. 컨텍스트 과부하**
```
증상:
- 대화 길이 45% 초과
- AI가 이전 내용 잊어버림
- /compact 후에도 품질 저하

해결: Explore/Plan Subagent로 분리
```

**2. 독립적인 작업**
```
예시:
- 코드 리뷰 (Security Reviewer)
- 테스트 작성 (Test Runner)
- 문서 생성 (Documentation Writer)

해결: 커스텀 Subagent 생성
```

**3. 역할 분담 필요**
```
예시:
- 대규모 리팩토링
- 여러 파일 동시 수정
- 복잡한 디버깅

해결: General-purpose Subagent
```

**사용 예시:**
```
"Explore Subagent로 인증 관련 파일 찾아줘"
"Security Subagent로 XSS 취약점 검사해줘"
"Test Runner Subagent로 테스트 실행해줘"
```

---

#### Q9: MCP는 필수인가요?

**필수 아님**: MCP 없이도 충분히 개발 가능

**있으면 매우 좋은 경우:**

**1. GitHub 헤비 유저**
```
✅ 이슈/PR 자주 관리
✅ 여러 리포지토리 작업
✅ 코드 리뷰 많음

효과: 탭 전환 제거, 30% 시간 절약
```

**2. 팀 협업**
```
✅ Slack으로 소통
✅ Jira로 이슈 관리
✅ Notion으로 문서화

효과: 통합 워크플로우
```

**3. 데이터 중심 작업**
```
✅ DB 쿼리 자주 실행
✅ API 테스트 반복
✅ 데이터 분석

효과: 직접 연동, 검증 자동화
```

**선택 가이드:**
```
초보자: MCP 건너뛰기 → 기본 학습에 집중
중급자: GitHub MCP만 설정 → 효과 체험
고급자: 여러 MCP 통합 → 워크플로우 최적화
```

---

#### Q10: 혼자 배우기 힘든데요?

**커뮤니티 & 리소스:**

**한국어 커뮤니티:**
- Discord: [Claude Code 한국 사용자 모임]
- 카카오톡: [에이전틱 코딩 오픈챗]
- 슬랙: [AI 코딩 크루]

**영어 커뮤니티:**
- Reddit: r/ClaudeCode
- GitHub Discussions: anthropics/claude-code
- Discord: Claude Official Server

**학습 자료:**
- YouTube: "Claude Code Tutorial"
- GitHub: awesome-claude-skills (5.5k stars)
- 블로그: claude.ai/blog

**1:1 도움:**
- Anthropic 공식 지원: support@anthropic.com
- Stack Overflow: [claude-code] 태그

**오프라인 모임:**
- 판교/강남 코딩 모임
- 대학 AI 동아리
- 스타트업 커뮤니티

**멘토링:**
- 오프소스 기여로 시작
- Code Review 요청
- 페어 프로그래밍 연습

---

## 8. 추천 학습 경로

### 🎯 레벨별 로드맵

#### 🥉 Bronze: 완전 초보자 (1주차)

**목표**: 첫 웹사이트 만들기

**Day 1-2: 개념 익히기**
```
□ 섹션 1 읽기 (기초 개발 용어)
□ 퀴즈:
  - 서버 vs 클라이언트 구분하기
  - 프론트엔드 vs 백엔드 구분하기
  - HTML/CSS/JS 역할 설명하기
```

**Day 3-4: 도구 선택 및 설치**
```
□ 웹 IDE 가입 (StackBlitz 추천)
  또는
□ 클로드코드 설치
□ 첫 프로젝트 생성
□ "Hello World" 출력하기
```

**Day 5-7: 첫 프로젝트**
```
□ 튜토리얼 1 완주 (To-Do 리스트)
□ 나만의 수정 추가
  - 색상 변경
  - 버튼 추가
  - 기능 하나 더 추가
□ 친구에게 공유
```

**🏆 주말 챌린지:**
"나만의 포트폴리오 사이트 만들기"
```
내용:
- 자기소개
- 프로젝트 목록
- 연락처

배우는 것:
- 레이아웃 구성
- 이미지 삽입
- 링크 연결
```

---

#### 🥈 Silver: 기본기 습득 (2-3주차)

**목표**: 중급 프로젝트 완성

**Week 2: 프롬프트 마스터**
```
Day 1-2: 구체적으로 요청하기
□ 프롬프트 엔지니어링 3원칙 학습
□ 나쁜 예 vs 좋은 예 비교
□ 10개 프롬프트 연습

Day 3-4: CLAUDE.md 작성
□ 프로젝트 규칙 문서화
□ 반복 설명 제거
□ # 키로 실시간 업데이트

Day 5-7: 컨텍스트 관리
□ /compact 사용 습관화
□ 40% 규칙 이해
□ SCRATCHPAD.md 활용
```

**Week 3: 중급 프로젝트**
```
선택지:
A. 블로그 시스템
   - 마크다운 렌더링
   - 포스트 목록/상세
   - 태그 필터링

B. 관리자 대시보드
   - 차트/그래프
   - 데이터 테이블
   - CRUD 기능

C. 나만의 아이디어
```

---

#### 🥇 Gold: 실전 활용 (4주차 이상)

**목표**: 고급 기능으로 효율 극대화

**Week 4: 고급 기능**
```
Day 1-3: Subagents
□ Explore로 코드 분석
□ Plan으로 전략 수립
□ 커스텀 Subagent 생성

Day 4-5: MCP 연동
□ GitHub MCP 설정
□ Slack 연동 (선택)
□ 워크플로우 통합

Day 6-7: Hooks & Skills
□ pre-commit 훅 설정
□ 팀 컨벤션 Skill 작성
□ 자동화 파이프라인 구축
```

**Week 5+: 대규모 프로젝트**
```
프로젝트 예시:
□ 쇼핑몰 (결제 연동)
□ SaaS 서비스 (구독 모델)
□ 커뮤니티 플랫폼
□ 오픈소스 기여

학습 초점:
- 복합 시스템 구축
- Skills × Subagents × MCP 통합
- 성능 최적화
- 보안 강화
```

---

### 📈 스킬 트리

```mermaid
graph TD
    A[시작] --> B{컴퓨터 기초}
    B -->|완료| C[기초 용어 학습]
    C --> D[웹 IDE 또는 CLI 선택]

    D --> E[Bronze: 첫 프로젝트]
    E --> F{자신감}
    F -->|낮음| E
    F -->|보통| G[Silver: 프롬프트 마스터]

    G --> H[중급 프로젝트]
    H --> I{준비됨?}
    I -->|No| G
    I -->|Yes| J[Gold: 고급 기능]

    J --> K[Subagents]
    J --> L[MCP]
    J --> M[Hooks & Skills]

    K --> N[전문가]
    L --> N
    M --> N

    N --> O[대규모 프로젝트]
    O --> P[오픈소스 기여]
    P --> Q[커뮤니티 멘토]
```

---

### 🎓 학습 스타일별 추천

**1. 빠른 실습형**
```
특징: 이론보다 만들면서 배우고 싶음

추천:
□ 튜토리얼 1부터 바로 시작
□ 에러 나면 그때그때 검색
□ 매일 1개씩 작은 프로젝트

예상 기간: 2주 → 중급
```

**2. 체계적 학습형**
```
특징: 개념 완벽 이해 후 실습

추천:
□ 가이드 전체 정독 (3일)
□ 퀴즈로 복습
□ 계획 세우고 프로젝트 시작

예상 기간: 4주 → 중급
```

**3. 목표 지향형**
```
특징: 만들고 싶은 게 명확함

추천:
□ 목표 프로젝트 정의
□ 필요한 부분만 선택 학습
□ 바로 프로젝트 착수

예상 기간: 1주 → 목표 달성
```

---

## 9. 용어 사전

### ㄱ

**Git (깃)**
- 뜻: 코드 변경 이력을 관리하는 도구
- 비유: 게임 세이브 포인트
- 관련: GitHub, 커밋, 푸시
- 상세: [깃 & 깃허브](#깃-git--깃허브-github)

**GitHub (깃허브)**
- 뜻: 깃 저장소 호스팅 서비스
- 비유: 코드의 클라우드 저장소
- 관련: Git, Pull Request, Issue

**GUI (지유아이)**
- 뜻: Graphical User Interface (그래픽 사용자 인터페이스)
- 반대: CLI (터미널)
- 예: 마우스로 클릭하는 화면

---

### ㄴ

**Node.js (노드)**
- 뜻: 브라우저 밖에서 JavaScript를 실행하는 환경
- 비유: JS를 컴퓨터에서 돌리는 엔진
- 상세: [Node.js & Next.js](#nodejs--nextjs--typescript)

**npm**
- 뜻: Node Package Manager
- 역할: JavaScript 라이브러리 설치 도구
- 명령어: `npm install`, `npm run dev`

---

### ㄷ

**Deploy (배포)**
- 뜻: 코드를 서버에 올려 공개
- 비유: 집들이 (인테리어 완성 후)
- 관련: Vercel, Netlify, AWS
- 상세: [도메인 & 배포](#도메인-domain--배포-deploy)

**다크모드**
- 뜻: 어두운 배경의 UI 테마
- 이유: 눈의 피로 감소, 배터리 절약

---

### ㄹ

**라이브러리 (Library)**
- 뜻: 미리 만들어진 코드 모음
- 비유: 레고 블록 세트
- 예시: React, jQuery, dayjs
- 상세: [라이브러리](#라이브러리-library)

**로컬 (Local)**
- 뜻: 내 컴퓨터 환경
- 반대: 호스팅 (클라우드)
- URL: localhost:3000

---

### ㅁ

**MCP**
- 뜻: Model Context Protocol
- 역할: AI가 외부 도구 사용하게 하는 프로토콜
- 예시: GitHub, Slack 연동
- 상세: [MCP](#mcp-model-context-protocol)

---

### ㅂ

**Bug (버그)**
- 뜻: 프로그램 오류
- 어원: 1947년 컴퓨터에 실제 벌레가 들어가 고장
- 관련: Debugging
- 상세: [버그 & 디버깅](#버그-bug-vs-디버깅-debugging)

**Backend (백엔드)**
- 뜻: 서버 쪽 코드
- 비유: 식당의 주방
- 역할: 데이터 처리, 비즈니스 로직
- 상세: [프론트엔드 vs 백엔드](#프론트엔드-frontend-vs-백엔드-backend)

---

### ㅅ

**Subagent (서브에이전트)**
- 뜻: 특정 역할에 특화된 하위 AI
- 비유: 회사의 각 부서
- 종류: Explore, Plan, General-purpose
- 상세: [서브에이전트](#클로드코드-서브에이전트-sub-agents)

**Skill (스킬)**
- 뜻: AI에게 가르치는 작업 방법
- 형식: 마크다운 파일 (SKILL.md)
- 위치: ~/.claude/skills/
- 상세: [스킬](#클로드코드-스킬-skills)

**Serverless (서버리스)**
- 뜻: 서버 관리 없이 코드 실행
- 예시: Vercel, AWS Lambda
- 장점: 자동 스케일링, 저렴

---

### ㅇ

**API**
- 뜻: Application Programming Interface
- 비유: 식당 점원 (주문 전달자)
- 역할: 프로그램 간 소통
- 상세: [API & JSON](#api--json)

---

### ㅈ

**JSON**
- 뜻: JavaScript Object Notation
- 역할: 데이터 교환 형식
- 형태: Key-Value 쌍
- 상세: [API & JSON](#api--json)

---

### ㅋ

**컨텍스트 (Context)**
- 뜻: AI의 기억 용량
- 한계: 200,000 토큰
- 관리: /compact, /clear
- 상세: [컨텍스트 관리](#컨텍스트-윈도우-관리-context-management)

**커밋 (Commit)**
- 뜻: 코드 변경 사항 저장
- 비유: 게임 저장
- 명령어: git commit -m "메시지"
- 상세: [커밋/푸시/풀](#커밋-commit-푸시-push-풀-pull)

**클라우드 (Cloud)**
- 뜻: 인터넷으로 접근하는 서버
- 예시: AWS, Google Cloud, Azure
- 반대: 온프레미스 (자체 서버)

---

### ㅌ

**터미널 (Terminal)**
- 뜻: 텍스트 명령어 입력 화면
- 별명: 콘솔, CLI, 커맨드라인
- Mac: Terminal.app
- Windows: PowerShell

---

### ㅍ

**프레임워크 (Framework)**
- 뜻: 개발 뼈대와 규칙
- 비유: 모델 하우스
- 예시: Next.js, Django, Rails
- 상세: [프레임워크](#프레임워크-framework)

**프론트엔드 (Frontend)**
- 뜻: 사용자가 보는 화면 쪽 코드
- 비유: 식당의 홀
- 기술: HTML, CSS, JavaScript
- 상세: [프론트엔드 vs 백엔드](#프론트엔드-frontend-vs-백엔드-backend)

**플러그인 (Plugin)**
- 뜻: 기능 확장 모듈
- 비유: 스마트폰 앱
- 명령어: /plugin marketplace
- 상세: [플러그인](#3-4-클로드코드-플러그인-plugins)

---

### ㅎ

**Hooks (훅)**
- 뜻: 특정 이벤트 시 자동 실행 스크립트
- 예시: pre-commit, post-save
- 위치: ~/.claude/hooks/
- 상세: [훅](#클로드코드-훅-hooks)

**HTML**
- 뜻: HyperText Markup Language
- 역할: 웹페이지 구조
- 비유: 건물의 뼈대
- 상세: [HTML & CSS & JS](#html--css--javascript)

---

### A-Z

**CSS**
- 뜻: Cascading Style Sheets
- 역할: 웹페이지 디자인
- 비유: 건물 외관
- 상세: [HTML & CSS & JS](#html--css--javascript)

**CLI**
- 뜻: Command Line Interface
- 역할: 텍스트 명령어 인터페이스
- 반대: GUI
- 예: 터미널, PowerShell

**CRUD**
- 뜻: Create, Read, Update, Delete
- 역할: 데이터 기본 조작 4가지
- 상세: [DB & CRUD](#db-database--crud)

**IDE**
- 뜻: Integrated Development Environment
- 역할: 통합 개발 환경
- 예: VS Code, WebStorm, StackBlitz

**REST API**
- 뜻: REpresentational State Transfer API
- 역할: 웹 서비스 통신 방식
- 특징: HTTP 기반, Stateless

**UI/UX**
- UI: User Interface (사용자 인터페이스)
- UX: User Experience (사용자 경험)
- 상세: [UI vs UX](#ui-user-interface-vs-ux-user-experience)

---

### 기호

**@Codebase**
- 뜻: 웹 IDE 명령어
- 역할: 전체 프로젝트 읽기
- 사용: "@Codebase 이거 수정해줘"

**/compact**
- 뜻: 클로드코드 명령어
- 역할: 대화 내용 요약
- 시기: 컨텍스트 40% 이상

**/clear**
- 뜻: 클로드코드 명령어
- 역할: 대화 전체 삭제
- 주의: 중요 정보 백업 후 사용

**/plan**
- 뜻: 플랜 모드 진입 명령어
- 역할: 코드 작성 전 계획 수립
- 단축키: Shift + Tab + Tab

---

**💡 용어를 더 깊이 이해하고 싶다면, 각 항목의 "상세" 링크를 클릭하세요!**
